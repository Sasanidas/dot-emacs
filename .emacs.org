#+AUTHOR: Sergei Nosov
#+EMAIL: sergei.nosov@gmail.com

* Foreword

This is a little novel for casual reading about a text editor. Incidentally, it
also works as an Emacs configuration file.

WARNING: WORK IN PROGRESS!

* Contents                                                              :TOC:
 - [[#foreword][Foreword]]
 - [[#ui-customization][UI customization]]
     - [[#lean-and-mean][Lean and mean]]
     - [[#dark-tango][Dark tango]]
     - [[#deja-vu][Deja Vu]]
     - [[#forbidden-fruit][Forbidden fruit]]
 - [[#external-packages][External packages]]
 - [[#abbreviations][Abbreviations]]
 - [[#dired][Dired]]
     - [[#dired-jump][Dired jump]]
     - [[#dired-details][Dired details]]
     - [[#dired-async][Dired async]]
     - [[#jumping-back-and-forth][Jumping back and forth]]
     - [[#do-what-i-mean][Do what I mean]]
     - [[#wdired][Wdired]]
     - [[#native-explorer][Native explorer]]
 - [[#things-to-remember][Things to remember]]

* UI customization

** Lean and mean

Emacs doesn't need a lot of UI elements - it should be lean and mean. Well, and
clean, and it should look good on the screen.

#+BEGIN_SRC emacs-lisp
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (setq inhibit-startup-message t)
#+END_SRC

** Dark tango

For some reason, my eyes like dark background. Not pitch black, but pretty
black.

#+BEGIN_SRC emacs-lisp
  (defun configure-theme ()
    "Make Emacs pretty"
    (load-theme 'tango-dark)
    (enable-theme 'tango-dark)
    ;; make background a little bit darker
    (set-background-color "#1d1f21"))

  (configure-theme)
#+END_SRC

** Deja Vu

DejaVu fonts family is simply the best one out there. And DejaVu Sans Mono is
the brightest child in the family:

- it covers a hell lot of Unicode symbols
- it's community-driven and MIT/public domain licensed
- it makes l, 1 and I clearly distinguishable, as well as 0 and O
- it's beautiful looking

Basically, DejaVu Sans Mono is a "font done right" for technical work.

#+BEGIN_SRC emacs-lisp
  (ignore-errors
    (set-frame-font
     (car (x-list-fonts "-*-DejaVu Sans Mono-normal-normal-normal-*-*-*-*-*-*-*-iso10646-1"))))
#+END_SRC

** Forbidden fruit

This section is supposed to make Emacs more usable on Mac's, but since I've
never owned a Mac, I can't really tell whether it works at all. If you own a
Mac, please, enlighten me!

#+BEGIN_SRC emacs-lisp
  (setq mac-command-modifier 'meta)
#+END_SRC

* External packages

* Abbreviations

I have a collection of abbreviations for commands, that I use rarely enough to
forget their actual spelling, but often enough to get annoyed every time I have
to look it up somewhere.

As a simplest example, I always forget how to use the =ln= command to create a
symbolic link. Where do you have to put =-s=? Where is the target path and where
is the link name? I know, it's ridiculous, but I was making mistakes every time
I tried to use it.

Now, I simply print =ln=, hit =M-/= for =hippie-expand= and it becomes =ln -s
target link= and I'm happy.

The abbreviations are listed in =.abbrev_defs= file and, basically, all of them
are commands, which do something simple, but are represented by a random-looking
symbols sequence.

I also use =yasnippet= for a similar functionality, but it didn't work very well
for me in minibuffer. And since I use minibuffer to issue shell commands (=M-&=)
quite often, I use abbreviations for common shell commands and =yasnippet= for
everything else.

#+BEGIN_SRC emacs-lisp
  (when (require 'abbrev nil t)
    (add-hook 'find-file-hook
              '(lambda()
                 (abbrev-mode -1)))
    (setq-default abbrev-mode nil))
#+END_SRC

* Dired

As you may know, dired stands for DIRectory EDitor and it is, basically, a file
manager inside Emacs.

I consider dired a truly amazing piece of software. More than anything, it makes
the job done without over-complication on implementation or interface side.

** Dired jump
To enable a convenient =C-x C-j= binding, we have to require the =dired-x=
module. =C-x C-j= opens current directory in dired, when visiting a file or
jumps to parent directory, when already in dired. With universal argument - =C-u
C-x C-j= - it opens dired in other window.

#+BEGIN_SRC emacs-lisp
  (define-key global-map (vector 'remap 'dired-jump)
    (defun dired-jump-universal-other (arg)
      "Calls dired-jump. With prefix argument uses other window"
      (interactive "P")
      (require 'dired-x)
      (dired-jump arg)))
#+END_SRC

** Dired details
=dired-details= module helps to hide a lot of unnecessary information inside
dired. You can toggle its visibility by pressing =h=:

#+BEGIN_SRC emacs-lisp
  (eval-after-load "dired-details-autoloads"
    '(progn
       (when (require 'dired-details nil t)
         (add-hook 'dired-mode-hook
                   '(lambda ()
                      (dired-details-install)
                      (setq dired-details-hidden-string "--- ")
                      (define-key dired-mode-map (kbd "h") 'dired-details-toggle))))))
#+END_SRC

** Dired async
=dired-async= module makes copying, renaming and deletion commands asynchronous:

#+BEGIN_SRC emacs-lisp
  (eval-after-load "async-autoloads"
    '(progn
       (if (require 'dired-async nil t)
           (progn
             (set-face-attribute 'dired-async-message nil
                                 :inherit 'mode-line-emphasis)
             (set-face-attribute 'dired-async-mode-message nil
                                 :inherit 'highlight))
         (warn "dired-async not found"))))
#+END_SRC

** Jumping back and forth
=beginning-of-buffer= and =end-of-buffer= commands should move the point to
better positions:

#+BEGIN_SRC emacs-lisp
  (define-key dired-mode-map (vector 'remap 'end-of-buffer)
    (defun dired-jump-to-bottom ()
      "Jumps to the last file"
      (interactive)
      (end-of-buffer)
      (dired-previous-line 1)))

  (define-key dired-mode-map (vector 'remap 'beginning-of-buffer)
    (defun dired-jump-to-top ()
      "Jumps to the .. entry"
      (interactive)
      (beginning-of-buffer)
      (dired-next-line 1)
      ;; skip another line depending on hidden/shown state of dired-details
      (when (or (not (boundp 'dired-details-state))
                (equal dired-details-state 'shown))
        (dired-next-line 1))
      (if (looking-at "\\.") ;; top-level directories don't have a
          ;; .. entry
          (dired-next-line 1))))
#+END_SRC

** Do what I mean

- If you have 2 dired windows opened, then copying and renaming should use the
  directory of the other window as a default target:

  #+BEGIN_SRC emacs-lisp
    (setq dired-dwim-target t)
  #+END_SRC

- Don't be afraid of recursive operations:

  #+BEGIN_SRC emacs-lisp
    (setq
     dired-recursive-copies (quote always)
     dired-recursive-deletes (quote always))
  #+END_SRC

- Group directories first:

  #+BEGIN_SRC emacs-lisp
    (setq dired-listing-switches
          (concat "-alh"
                  (when (not (equal window-system 'w32))
                    " --group-directories-first")))
  #+END_SRC

** Wdired

When editing dired buffer (=C-x C-q=), allow to change the permissions as well:

#+BEGIN_SRC emacs-lisp
  (define-key dired-mode-map (kbd "C-x C-q") 'dired-toggle-read-only)
  (setq wdired-allow-to-change-permissions t)
#+END_SRC

** Native explorer

Use =E= in dired to open a system's native file explorer in current directory:

#+BEGIN_SRC emacs-lisp
  (define-key dired-mode-map (kbd "E")
    (defun open-window-manager ()
      "Open default system windows manager in current directory"
      (interactive)
      (save-window-excursion
        (if (equal window-system 'w32)
            (async-shell-command "explorer .")
          (if (equal window-system 'x)
              (async-shell-command "nautilus ."))))))
#+END_SRC

* Things to remember
- append-tramp-host in dired
- terminal emulator
