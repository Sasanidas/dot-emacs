#+AUTHOR: Sergei Nosov
#+EMAIL: sergei.nosov@gmail.com

* Foreword

This is a little novel for casual reading about a text editor. Incidentally, it
also works as an Emacs configuration file.

* Contents                                                              :TOC@1:
 - [[#foreword][Foreword]]
 - [[#ui-customization][UI customization]]
 - [[#abbreviations][Abbreviations]]
 - [[#dired][Dired]]
 - [[#better-buffer-names][Better buffer names]]
 - [[#a-student-has-become-a-pupil][A student has become a pupil]]
 - [[#spelling-fly][Spelling fly]]
 - [[#string-edit][String edit]]
 - [[#images-in-the-same-directory][Images in the same directory]]
 - [[#parenthesis-for-dummies][Parenthesis for Dummies]]
 - [[#programming-languages][Programming languages]]
 - [[#magit][Magit]]
 - [[#unstructured-configuration][Unstructured configuration]]

* UI customization
** Lean and mean

Emacs doesn't need a lot of UI elements - it should be lean and mean. Well, and
clean, and it should look good on the screen.

#+BEGIN_SRC emacs-lisp
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (setq inhibit-startup-message t)
#+END_SRC

** Dark tango

For some reason, my eyes like dark background. Not pitch black, but pretty
black.

#+BEGIN_SRC emacs-lisp
  (funcall
   (defun configure-theme ()
     "Make Emacs pretty"
     (load-theme 'tango-dark)
     (enable-theme 'tango-dark)
     ;; make background a little bit darker
     (set-background-color "#1d1f21")))
#+END_SRC

** Deja Vu

DejaVu fonts family is simply the best one out there. And DejaVu Sans Mono is
the brightest child in the family:

- it's sans-serif
- it's mono-space
- it covers a great amount of Unicode symbols
- it's community-driven and MIT/public domain licensed
- it makes l, 1 and I clearly distinguishable, as well as 0 and O
- it's beautiful

Basically, DejaVu Sans Mono is a "font done right" for technical work.

#+BEGIN_SRC emacs-lisp
  (ignore-errors
    (set-frame-font
     (car (x-list-fonts "-*-DejaVu Sans Mono-normal-normal-normal-*-*-*-*-*-*-*-iso10646-1"))))
#+END_SRC

** Forbidden fruit

This section is supposed to make Emacs more usable on Mac's, but since I've
never owned a Mac, I can't really tell whether it works at all. If you own a
Mac, please, enlighten me!

#+BEGIN_SRC emacs-lisp
  (setq mac-command-modifier 'meta)
#+END_SRC

* Abbreviations

I have a collection of abbreviations for commands, that I use rarely enough to
forget their actual spelling, but often enough to get annoyed every time I have
to look it up somewhere.

As a simplest example, I always forget how to use the =ln= command to create a
symbolic link. Where do you have to put =-s=? Where is the target path and where
is the link name? I know, it's ridiculous, but I was making mistakes every time
I tried to use it.

Now, I simply print =ln=, hit =M-/= for =hippie-expand=, it becomes =ln -s
target link= and I'm happy.

The abbreviations are listed in =.abbrev_defs= file and, basically, all of those
are commands, which do something simple, but are represented by a random-looking
symbols sequence.

I also use =yasnippet= for a similar functionality, but it didn't work very well
in minibuffer for me. And since I use minibuffer to issue shell commands (=M-&=)
quite often, my rule of thumb is to use abbreviations for common shell commands
and =yasnippet= for everything else.

#+BEGIN_SRC emacs-lisp
  (when (require 'abbrev nil t)
    (add-hook 'find-file-hook
              '(lambda()
                 (abbrev-mode -1)))
    (setq-default abbrev-mode nil))
#+END_SRC

* Dired

As you may know, dired stands for DIRectory EDitor and it is, basically, a file
manager inside Emacs.

I consider dired a truly amazing piece of software. More than anything, it makes
the job done without over-complication on implementation or interface side.

** Dired jump
To enable a convenient =C-x C-j= binding, we have to require the =dired-x=
module. When visiting a file, =C-x C-j= opens current directory in dired. When
already in dired, it jumps to the parent directory and it is also bound to a
nice shortcut - =j=. With universal argument - =C-u C-x C-j= - it opens dired in
other window.

#+BEGIN_SRC emacs-lisp
  (when (require 'dired-x nil t)
    (define-key dired-mode-map (kbd "j")
      (define-key global-map (vector 'remap 'dired-jump)
        (defun dired-jump-universal-other (arg)
          "Calls dired-jump. With prefix argument uses other window"
          (interactive "P")
          (dired-jump arg)))))
#+END_SRC

** Dired details
=dired-details= module helps to hide a lot of unnecessary information inside
dired. You can toggle its visibility by pressing =h=:

#+BEGIN_SRC emacs-lisp
  (eval-after-load "dired-details-autoloads"
    '(progn
       (when (require 'dired-details nil t)
         (add-hook 'dired-mode-hook
                   '(lambda ()
                      (dired-details-install)
                      (setq dired-details-hidden-string "--- ")
                      (define-key dired-mode-map (kbd "h") 'dired-details-toggle))))))
#+END_SRC

** Dired async
=dired-async= module makes copying, renaming and deletion commands asynchronous:

#+BEGIN_SRC emacs-lisp
  (eval-after-load "async-autoloads"
    '(progn
       (if (require 'dired-async nil t)
           (progn
             (set-face-attribute 'dired-async-message nil
                                 :foreground nil
                                 :inherit 'mode-line-emphasis)
             (set-face-attribute 'dired-async-mode-message nil
                                 :background nil
                                 :inherit 'highlight))
         (message "WARNING: dired-async not found"))))
#+END_SRC

** Jumping back and forth
=beginning-of-buffer= and =end-of-buffer= commands should move the point to
better positions:

#+BEGIN_SRC emacs-lisp
  (define-key dired-mode-map (vector 'remap 'end-of-buffer)
    (defun dired-jump-to-bottom ()
      "Jumps to the last file"
      (interactive)
      (end-of-buffer)
      (dired-previous-line 1)))

  (define-key dired-mode-map (vector 'remap 'beginning-of-buffer)
    (defun dired-jump-to-top ()
      "Jumps to the .. entry"
      (interactive)
      (beginning-of-buffer)
      (dired-next-line 1)
      ;; skip another line depending on hidden/shown state of dired-details
      (when (or (not (boundp 'dired-details-state))
                (equal dired-details-state 'shown))
        (dired-next-line 1))
      (if (looking-at "\\.") ;; top-level directories don't have a
          ;; .. entry
          (dired-next-line 1))))
#+END_SRC

** Do what I mean

- If you have 2 dired windows opened, then copying and renaming should use the
  directory of the other window as a default target:

  #+BEGIN_SRC emacs-lisp
    (setq dired-dwim-target t)
  #+END_SRC

- Don't be afraid of recursive operations:

  #+BEGIN_SRC emacs-lisp
    (setq
     dired-recursive-copies (quote always)
     dired-recursive-deletes (quote always))
  #+END_SRC

- Group directories first:

  #+BEGIN_SRC emacs-lisp
    (setq dired-listing-switches
          (concat "-alh"
                  (when (not (equal window-system 'w32))
                    " --group-directories-first")))
  #+END_SRC

** Wdired

When editing dired buffer (=C-x C-q=), allow to change the permissions as well:

#+BEGIN_SRC emacs-lisp
  (define-key dired-mode-map (kbd "C-x C-q") 'dired-toggle-read-only)
  (setq wdired-allow-to-change-permissions t)
#+END_SRC

** Native explorer

Use =E= in dired to open a system's native file explorer in current directory:

#+BEGIN_SRC emacs-lisp
  (define-key dired-mode-map (kbd "E")
    (defun open-window-manager ()
      "Open default system windows manager in current directory"
      (interactive)
      (save-window-excursion
        (if (equal window-system 'w32)
            (async-shell-command "explorer .")
          (if (equal window-system 'x)
              (async-shell-command "nautilus ."))))))
#+END_SRC

** Tar (Tahr? Thar?)

One thing that makes me upset about Dired is its somewhat limited support for
compression. Yes, there's a =Z= key for this, but

- it doesn't compress directories
- when multiple files are marked, each file is compressed to a separate archive,
  which is not what I want in 98.6% of cases

For some reason Dired is not very customizable in that regard. At least, I
couldn't find a way to alter its behavior without a complete rewrite of related
functions.

So, I ended up with a small function which does what I want in 98.6% of cases.
You press =z=, and it asks you for an output archive name. If multiple files are
marked at the moment, it will compress those into a single archive. And,
surprisingly, it works for directories, too!

If I want to untar an archive, I simply use =&= which suggests untaring as a
first guess.

#+BEGIN_SRC emacs-lisp
  (define-key dired-mode-map (kbd "z")
    (defun dired-tar-marked-files ()
      "Ask a name for a .tar.gz archive and compress the marked
  files into it. If no files are marked or a numeric prefix arg is
  given, the next ARG files are used. Just C-u means the current
  file. The prompt mentions the file(s) or the marker, as
  appropriate."
      (interactive)
      (let* ((files (dired-get-marked-files t current-prefix-arg))
             (out-name (concat
                        (if (equal (length files) 1)
                            (file-name-nondirectory (car files))
                          (file-name-base (directory-file-name (expand-file-name default-directory))))
                        ".tar.gz")))
        (async-shell-command (concat
                              "tar -czvf "
                              (dired-mark-pop-up
                               nil 'shell files
                               'read-shell-command
                               (format "Output file name for 'tar -czvf' on %s: "
                                       (dired-mark-prompt current-prefix-arg files))
                               out-name nil)
                              " "
                              (mapconcat 'identity files " "))))))
#+END_SRC
* Better buffer names

** Default uniquification

If you open several files with the same name, then a good way to distinguish
between those is to prepend parent directory names to file names. If the names
still conflict, you can add another parent directory levels, until the clash is
resolved

#+BEGIN_SRC emacs-lisp
  (when (require 'uniquify nil t)
    (setq uniquify-buffer-name-style 'forward))
#+END_SRC

** Append tramp host

For remote files, opened with TRAMP, it makes sense to append the hostname to
the buffer name.

#+BEGIN_SRC emacs-lisp
  (when (require 'tramp nil t)
    (defun append-tramp-host ()
      "Appends host name to the current buffer name for remote
  files"
      (interactive)
      (when (tramp-tramp-file-p default-directory)
        (rename-buffer
         (concat
          (replace-regexp-in-string " <.*>$" "" (or (uniquify-buffer-base-name) (buffer-name)))
          " <"
          (tramp-file-name-host
           (tramp-dissect-file-name default-directory)) ">")
         t)))

    (add-hook 'find-file-hook 'append-tramp-host)
    (add-hook 'dired-mode-hook 'append-tramp-host))
#+END_SRC

** Rename buffer

In case you have a better name for a buffer, you can always rename it by
pressing =C-x C-r=.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "\C-x\C-r") 'rename-buffer)
#+END_SRC

* A student has become a pupil

There's a couple of alternatives to the built-in functions of Emacs, that try to
be smarter about what they do, while closely maintaining the original intent and
implementation.

** Searching

If you select a region, that entirely lies on a single line, then incremental
searching (=C-s= and =C-r=) will use it as an initial value and make a first
jump. The common way I use it is:

- mark a word or a longer unit with =er/expand-region= (=C-==)
- press =C-s= or =C-r= to jump to the next or previous occurrence

#+BEGIN_SRC emacs-lisp
  (defmacro smart-isearch (direction)
    `(defun ,(intern (format "smart-isearch-%s" direction)) (&optional regexp-p no-recursive-edit)
       "If region is active and non empty, use it for searching and
    make first jump. Otherwise, behave like original function."
       (interactive "P\np")
       (let ((smart-p (and
                       (region-active-p)
                       (< (region-beginning) (region-end))
                       (= (- (line-number-at-pos (region-end))
                             (line-number-at-pos (region-beginning))) 0)
                       )))
         (when smart-p
           (kill-ring-save (region-beginning) (region-end)))

         (,(intern (format "isearch-%s" direction)) regexp-p no-recursive-edit)

         (when smart-p
           (isearch-yank-kill)
           (,(intern (format "isearch-repeat-%s" direction)))))))
  (define-key global-map [remap isearch-forward]  (smart-isearch forward))
  (define-key global-map [remap isearch-backward] (smart-isearch backward))
#+END_SRC

Similarly, =occur= (=M-s o=) will use the selected region, if any, without
prompting. By the way, you can press =M-s o= during incremental search to
call =occur= for the current search string.

#+BEGIN_SRC emacs-lisp
  (define-key global-map [remap occur]
    (defun smart-occur (arg)
      (interactive "P")
      (if (region-active-p)
          (occur (buffer-substring-no-properties (region-beginning) (region-end)) arg)
        (call-interactively 'occur))))
#+END_SRC

I got used to the convention of =C-x C-q= being a toggle between writable and
read-only buffer states. It's better for occur mode to follow this convention.

#+BEGIN_SRC emacs-lisp
  (define-key occur-mode-map "\C-x\C-q" 'occur-edit-mode)
  (define-key occur-edit-mode-map "\C-x\C-q" 'occur-cease-edit)
#+END_SRC

** Beginning of line

When jumping to the beginning of line, more often than not you actually want to
jump to the first non-whitespace character. So, the default behavior of
=beginning-of-line= (=C-a=) is remapped to =back-to-indentation=. In case you
actually wanted to go to the very beginning of the line, you should hit =C-a=
one more time.

#+BEGIN_SRC emacs-lisp
  (define-key global-map [remap move-beginning-of-line]
    (defun smart-beginning-of-line ()
      "Move point to first non-whitespace character or beginning-of-line.

    Move point to the first non-whitespace character on this line.
    If point was already at that position, move point to beginning of line."
      (interactive)
      (let ((oldpos (point)))
        (back-to-indentation)
        (and (= oldpos (point))
             (beginning-of-line)))))
#+END_SRC

** Free advice

It is so natural and convenient for the just yanked region to be properly
indented, that I got used to this functionality even before I turned it on. On
the rare occasions you can use universal argument to suppress auto indentation.

#+BEGIN_SRC emacs-lisp
  (defadvice insert-for-yank-1 (after indent-region activate)
    "Indent yanked region in certain modes, C-u prefix to disable"
    (if (and (not current-prefix-arg)
             (member major-mode '(sh-mode
                                  emacs-lisp-mode lisp-mode
                                  c-mode c++-mode objc-mode d-mode java-mode cuda-mode
                                  LaTeX-mode TeX-mode
                                  xml-mode html-mode css-mode)))
        (indent-region (region-beginning) (region-end) nil)))
#+END_SRC

* Spelling fly

Can't tell it for sure, but I suspect that even the brightest spelling bee
champions hit the wrong button once in a while. So, it's good to have an
automated spell-checking in every text buffer you edit. It would be an overkill
for editing source code, since everybody loves identifiers like "src", "lhs",
"rhs", "ptr", "uniq", "img", "gl", "qq" and a gazillion of other pretty names.

When the cursor is under the red-highlighted word, you can press =M-$= to look
for alternative spellings.

By default, only words under the cursor are checked for correctness. So, if you
want to spell check the whole buffer (or region), hit =C-x M-$=. To go to the
next error, hit "C-,". To auto-correct the next word, hit =C-.=.

I edit texts in both Russian and English and I have to spell check both of the
languages. To toggle between those dictionaries I use =C-c M-$=. If you want to
toggle (cycle, actually) between (through) other languages, you can customize
the =ispell-common-dictionaries= variable.

#+BEGIN_SRC emacs-lisp
  (when (require 'flyspell nil t)
    (add-hook 'text-mode-hook 'flyspell-mode)
    (add-hook 'prog-mode-hook 'flyspell-prog-mode)

    (defcustom ispell-common-dictionaries
      '("en" "ru")
      "List of dictionaries for common use")

    (setq ispell-dictionary (car ispell-common-dictionaries))

    (define-key flyspell-mode-map (kbd "C-c M-$")
      (defun ispell-next-dictionary()
        "Cycle through dictionaries in `ispell-common-dictionaries'"
        (interactive)
        (let* ((dic ispell-current-dictionary)
               (next (cadr (member dic ispell-common-dictionaries)))
               (change (if next next (car ispell-common-dictionaries))))
          (ispell-change-dictionary change))))

    (define-key flyspell-mode-map (kbd "C-x M-$")
      (defun flyspell-buffer-or-region ()
        (interactive)
        (if (region-active-p)
            (flyspell-region (region-beginning) (region-end))
          (flyspell-buffer)))))
#+END_SRC
* String edit

It is frustratingly difficult to follow special characters and sequences in
strings. Especially, in regular expressions, where you have 2 levels deep
languages hierarchy. This leads to strings, like, =\\\\= (4 backslashes) for
matching a =\= (single backslash).

With string-edit mode you can press =C-c e= to edit a string at point without
escape sequences, breaking one level of nesting.

To finish editing, press =C-c C-c=. To abort, press =C-c C-k=.

#+BEGIN_SRC emacs-lisp
  (eval-after-load "string-edit-autoloads"
    '(progn
       (if (require 'string-edit nil t)
           (progn
             (global-set-key "\C-ce" 'string-edit-at-point)
             (define-key string-edit-mode-map (vector 'remap 'kill-this-buffer) 'string-edit-abort))
         (message "WARNING: string-edit not found"))))
#+END_SRC

As a side note, for the particular case of editing regular expressions, you can
also use the command =M-x re-builder= to interactively construct highly
sophisticated expressions.

* Images in the same directory

When you want to look through the images in a directory, it is convenient to
visit next and previous images with shortcuts - =n= and =p=. This functionality
is built-in since Emacs 24.4, but until I switch, I need special functions for
that. Note, that those functions only traverse images with the same extension as
the current one.

#+BEGIN_SRC emacs-lisp
  (when (require 'image-mode nil t)
    (define-key image-mode-map "n"
      (defun next-image (arg)
        "Visit the next arg'th image in the same directory of the
  same type."
        (interactive "P")
        (unless (and (buffer-file-name) (eq major-mode 'image-mode))
          (error "Not visiting a file in image mode"))
        (let* ((files   (directory-files
                         (file-name-directory (buffer-file-name)) nil
                         (file-name-extension (buffer-file-name)) ))
               (len     (length files))
               (this    (file-name-nondirectory (buffer-file-name)))
               (idx     0)
               (dir     (file-name-directory (buffer-file-name))))
          (dolist (file files)
            (if (not (string= this file))
                (setq idx  (1+ idx))
              (setq idx
                    (mod (+ idx (if arg arg 1)) len))
              (kill-this-buffer) ;; we don't want to have a thousand image
              ;; buffers around
              (find-file (concat dir (elt files idx))))))))

    (define-key image-mode-map "p"
      (defun previous-image (arg)
        "Visit previous image. See `next-image'"
        (interactive "P")
        (next-image (if arg (- arg) -1)))))
#+END_SRC

* Parenthesis for Dummies

I'm kind of ashamed to be the author of =dummyparens= mode. But I tried not to
be one really hard.

The thing is, I wanted a really simple auto-pairing functionality with only 2
requirements:

- after I press =(=, =[=, ="= and ={= it should behave like if I pressed the key
  of the corresponding closing pair immediately
- if the region is selected, when I press an opening symbol, it should be
  wrapped

Simple as that. Easiest thing in the world. But not only I didn't find a
built-in solution for that, I didn't find a decent solution at all!

The first option is, obviously, =electric-pair=. It's built-in and lightweight -
great. But for some reason it doesn't insert the closing pair if the following
character is non-whitespace. It also doesn't support wrapping.

The next promising candidate was =autopair= supporting both auto-pairing and
wrapping. It was "almost there", but there were 2 reasons why I couldn't live
with it:

- It uses =insert= function to insert symbols and, generally speaking, it is not
  quite correct to do so. Like, for example, =cc-mode= has it's own binding for
  opening parenthesis - =c-electric-paren=, which sometimes indents the current
  line among other things. So, if you're using =autopair=, you're losing this
  behavior.
- But worse than that - =autopair= was doing a lot of fancy stuff out-of-the-box
  and I constantly had to fight my way through to make it as unobtrusive as
  possible. And still, I kept encountering corner cases, when it tried to be
  smarter than it should.

Probably, after fighting long enough, I could make =autopair= work as I wanted
it to. But why fight so hard, if I knew I could implement the desired
functionality with much smaller effort?

Before I did this, my last try was =smartparens=. The description was thoughtful
and sensible. But when I tried it, I was horrified. The thing actually puts an
overlay on braces, has some notion of state and prints messages to the echo
area - all of this for a pair of braces.

It was the point when I exclaimed "That does it! I'm writing my own auto-pairing
mode! With blackjack and wrapping!"

The key moments of the mode are:
- It's under 100 lines of code.
- When you press an opening pair key, it issues the exact same command as if the
  mode was off. Then it "presses" the closing pair key (i.e. issues the exact
  same command as if the mode was off)
- If the region is selected - it is wrapped.
- Optionally, it runs a "post-handler" hook, which can be any function you want.
  Personally, I have a single hook, enabled for curly braces (={=). It indents
  the just wrapped region - very convenient for the C-family languages.

I could easily fit these 100 lines of code in the configuration file. But I want
to believe, that I'm not mad. That somebody else might find this functionality
useful as well.

#+BEGIN_SRC emacs-lisp
  (eval-after-load "dummyparens-autoloads"
    '(progn
       (if (require 'dummyparens nil t)
           (global-dummyparens-mode)
         (message "WARNING: dummyparens not found"))))
#+END_SRC

* Programming languages
** Compile

All I really need for programming is =C-c C-c= to issue =compile= command and
being able to jump to the line with the error from the compilation buffer.

The only nifty trick I find particularly useful is to make =compile-command=
variable buffer-local. After that each buffer will remember what compilation
command was issued from it and suggest it on the successive call.

This replaces all the "project management" nonsense for me. It's incredibly
flexible, convenient and simple at the same time. Truly, great stuff.

#+BEGIN_SRC emacs-lisp
  (when (require 'compile nil t)
    (make-variable-buffer-local 'compile-command)

    ;; those patterns are used by dmd compiler
    (setq compilation-error-regexp-alist
          (append '(("^\\(.*?\\)(\\([0-9]+\\)): Warning:" 1 2 nil 1)
                    ("^\\(.*?\\)(\\([0-9]+\\)): Error:" 1 2 nil 2))
                  compilation-error-regexp-alist)))
#+END_SRC

** Python

Probably, the most prominent package for Python development is =elpy=. At least
it was, when I checked last time. It has all the "cool kids" features:
auto-completion, refactoring, documentation access, etc.

Personally, I don't find those features to be a big deal. So, when =elpy=
explicitly refused to work on a remote python script, I removed it without
second thought.

I also don't really need a shell (or REPL), since I'm not used to interpreters.
But if I'm to pick one for Python, it will, obviously, be =ipython=.

#+BEGIN_SRC emacs-lisp
  (when (require 'python nil t)
    (if (executable-find "ipython")
        (setq
         python-shell-interpreter "ipython"
         python-shell-prompt-regexp "In \\[[0-9]+\\]: "
         python-shell-prompt-output-regexp "Out\\[[0-9]+\\]: "))

    (add-hook 'python-mode-hook
              '(lambda ()
                 (define-key python-mode-map (kbd "\C-c\C-c") 'compile)
                 (define-key python-mode-map (kbd "\C-c\C-e") 'python-shell-send-buffer))))
#+END_SRC

** Markdown

In my opinion, =markdown-mode= is somewhat overwhelming in its functionality. It
binds too many combinations to the extent when it starts to feel obtrusive.

If I were to implement a Markdown mode, I would try to mimic it as closely to
=org-mode= as possible. But, apparently, =markdown-mode= authors have another
point of view, so the mode is different in almost everything it does.

So, the only things, that I actually use in this mode is syntax highlighting and
a =markdown-export= function (=C-c C-e=).

#+BEGIN_SRC emacs-lisp
  (eval-after-load "markdown-mode-autoloads"
    '(progn
       (if (require 'markdown-mode nil t)
           (progn
             (setq auto-mode-alist (cons '("\\.md" . markdown-mode) auto-mode-alist))

             (define-key markdown-mode-map (kbd "M-p") nil)
             (define-key markdown-mode-map (kbd "M-n") nil)
             (define-key markdown-mode-map (kbd "\C-c\C-c") nil)
             (define-key markdown-mode-map (kbd "\C-c\C-e") 'markdown-export))
         (message "WARNING: markdown-mode not found"))))
#+END_SRC

** D

The only unusual thing about this mode is that it alters the default syntax
indentation. It lines up the dots in situations, like

#+BEGIN_SRC d
  foreach (file; dirPath.expandTilde()
                        .buildNormalizedPath()
                        .dirEntries(SpanMode.shallow)()
#+END_SRC

There's kind of a funny story around this functionality. Somebody asked a
[[https://stackoverflow.com/questions/25797945/adjusting-alignment-rules-for-ucfs-chains-in-d][question]] on StackOverflow about how you can achieve this. I got interested and
started to dig.

Surprisingly, there was a built-in function for that, called
=c-lineup-cascaded-calls=, so you all you had to do is to put it in the right
place. But where is that place?

Turns out there's a =c-offsets-alist= variable, which contains the indentation
rules in the following format: =(<applicable place> . <rule>)=. Here,
=<applicable place>= stands for a keyword understood by the C indentation
engine, like =statement-cont= (continuation of the statement).

So far, so good. The =statement-cont= keyword worked like a charm. But it didn't
work for the particular case from the question. Apparently, there was some other
keyword for that place and I had to find out what it was.

After a long trial and error session, I found out there's a variable
=c-echo-syntactic-information-p=. One can set it to =t= and on every indentation
call after that, the information about current position will be displayed in the
echo area.

The keyword I was looking for turned out to be =arglist-cont-nonempty=.

But it was only a half of the problem. The =c-lineup-cascaded-calls= function
didn't work in some important cases:

- when function calls didn't have any parenthesis (which are optional in D)
- when calling a function with compile-time parameters, e.g.
  =func!(compiletime)(runtime)=

I posted a dirty rewrite of =c-lineup-cascaded-calls= to the StackOverflow
answer and it went right down to the =d-mode= repository, so I had to enable it
in my setup. Not that I find this indentation strategy particularly useful, but
I don't feel like dropping it after putting so much effort into it.

#+BEGIN_SRC emacs-lisp
  (eval-after-load "d-mode-autoloads"
    '(progn
       (when (require 'd-mode nil t)
         (when (fboundp 'd-lineup-cascaded-calls)
           (add-hook 'd-mode-hook
                     '(lambda ()
                        (add-to-list 'c-offsets-alist '(arglist-cont-nonempty . d-lineup-cascaded-calls))
                        (add-to-list 'c-offsets-alist '(statement-cont . d-lineup-cascaded-calls)))))
         (setq auto-mode-alist
               (append '(("\\.d\\'" . d-mode)
                         ("\\.di\\'" . d-mode))
                       auto-mode-alist)))))
#+END_SRC

** Misc

Nothing special, really.

*** YAML

#+BEGIN_SRC emacs-lisp
  (eval-after-load "yaml-mode-autoloads"
    '(progn
       (if (require 'yaml-mode nil t)
           (add-to-list 'auto-mode-alist '("\\.yml$" . yaml-mode))
         (message "WARNING: yaml-mode not found"))))
#+END_SRC

*** CMake

#+BEGIN_SRC emacs-lisp
  (eval-after-load "cmake-mode-autoloads"
    '(progn
       (when (require 'cmake-mode nil t)
         (setq auto-mode-alist
               (append '(("CMakeLists\\.txt\\'" . cmake-mode)
                         ("CMakeCache\\.txt\\'" . cmake-mode)
                         ("\\.cmake\\'" . cmake-mode))
                       auto-mode-alist)))))
#+END_SRC

*** DOS

#+BEGIN_SRC emacs-lisp
  (eval-after-load "dos-autoloads"
    '(progn
       (when (require 'dos nil t)
         (setq auto-mode-alist
               (append '(("\\.cmd\\'" . dos-mode)
                         ("\\.bat\\'" . dos-mode))
                       auto-mode-alist)))))
#+END_SRC

* Magit

There's not enough words in any human language to describe the brilliance of
=magit=. So, let's simply take a minute and think about cosmic order of things
in silence.

#+BEGIN_SRC emacs-lisp
  (eval-after-load "magit-autoloads"
    '(progn
       (if (require 'magit nil t)
           (progn
             (require 'gitignore-mode nil t)
             (require 'gitconfig-mode nil t)
             (require 'gitattributes-mode nil t)

             (setq
              magit-revert-item-confirm nil
              magit-diff-refine-hunk t)

             (set-face-attribute 'magit-item-highlight nil
                                 :background "black")

             (global-set-key (kbd "\C-c m")      'magit-status)
             (global-set-key (kbd "\C-c RET")    'magit-status))
         (message "WARNING: magit not found"))))
#+END_SRC

* Unstructured configuration

Right now this section is simply a copy-paste of my old configuration. I
gradually move things from this section to separate ones.

#+BEGIN_SRC emacs-lisp
  ;; ------------------------------------------------------------
  ;; BUILT-IN DEPENDENCIES

  ;; for zap-up-to-char
  (require 'misc)

  ;; for git-grep command
  (require 'vc-git)
  (require 'grep)

  ;; hippie-expand
  (require 'hippie-exp)

  ;; ibuffer
  (when (require 'ibuffer nil t)
    ;; ibuffer groups
    (setq ibuffer-saved-filter-groups
          (quote (("default"
                   ("org"  (mode . org-mode))
                   ("dired" (mode . dired-mode))
                   ("D" (mode . d-mode))
                   ("C/C++" (or
                             (mode . cc-mode)
                             (mode . c-mode)
                             (mode . c++-mode)))
                   ("magit" (name . "^\\*magit"))
                   ("Markdown" (mode . markdown-mode))
                   ("emacs" (name . "^\\*Messages\\*$"))
                   ("shell commands" (name . "^\\*.*Shell Command\\*"))
                   ))))
    (add-hook 'ibuffer-mode-hook
              (lambda ()
                (ibuffer-switch-to-saved-filter-groups "default"))))

  ;; ------------------------------------------------------------
  ;; PER-PACKAGE CONFIGURATION

  (eval-after-load "auto-complete-autoloads"
    '(progn
       (when (require 'auto-complete nil t)
         (require 'auto-complete-config)

         (defun ac-expand-no-next ()
           "Try expand, and if expanded twice, complete."
           (interactive)
           (unless (ac-expand-common)
             (let ((string (ac-selected-candidate)))
               (when string
                 (if (equal ac-prefix string)
                     (ac-complete)
                   (ac-expand-string string (eq last-command this-command))
                   ;; Do reposition if menu at long line
                   (if (and (> (popup-direction ac-menu) 0)
                            (ac-menu-at-wrapper-line-p))
                       (ac-reposition))
                   (setq ac-show-menu t)
                   string)))))

         (ac-flyspell-workaround)
         (setq-default ac-use-comphist nil)
         (define-key ac-completing-map [tab] 'ac-expand-no-next)
                                          ;(define-key ac-completing-map "\r" nil)

         (defun ac-yasnippet-candidates-sorted-by-length ()
           "Sorts yasnippet candidates by length."
           (sort (ac-yasnippet-candidates) '(lambda (l r) (< (length l) (length r)))))

         (ac-define-source yasnippet
           '((depends yasnippet)
             (candidates . ac-yasnippet-candidates-sorted-by-length)
             (action . yas-expand)
             (candidate-face . ac-yasnippet-candidate-face)
             (selection-face . ac-yasnippet-selection-face)
             (symbol . "a")))

         (add-hook 'emacs-lisp-mode-hook
                   '(lambda ()
                      (auto-complete-mode t)
                      (setq ac-sources '(
                                         ac-source-yasnippet
                                         ac-source-features
                                         ac-source-functions
                                         ac-source-variables
                                         ac-source-symbols
                                         ac-source-words-in-same-mode-buffers
                                         ))))

         (when (and (require 'ac-dcd nil t) (require 'd-mode nil t))
           (if (and (executable-find ac-dcd-server-executable)
                    (executable-find ac-dcd-executable))
               (progn
                 (add-hook 'd-mode-hook
                           '(lambda ()
                              (auto-complete-mode t)
                              (ac-dcd-maybe-start-server)
                              (setq ac-sources '(
                                                 ac-source-yasnippet
                                                 ac-source-dcd
                                                 ac-source-words-in-same-mode-buffers
                                                 ))))
                 (define-key d-mode-map [remap find-tag]     'ac-dcd-goto-definition)
                 (define-key d-mode-map [remap pop-tag-mark] 'ac-dcd-goto-def-pop-marker)
                 (define-key d-mode-map (kbd "M-?")          'ac-dcd-show-ddoc-with-buffer)
                 (define-key d-mode-map (kbd "C-c i")        'ac-dcd-add-imports))
             (message "WARNING: dcd-server not found"))))))

  (eval-after-load "org-autoloads"
    '(progn
       (when (require 'org nil t)
         ;; enable python execution in org-mode
         (require 'ob-python)
         (require 'ob-R)

         (defun conditional-org-reveal-export-to-html ()
           (save-excursion
             (beginning-of-buffer)
             (when (search-forward "#+REVEAL" nil nil)
               (org-reveal-export-to-html))))

         (add-hook 'org-ctrl-c-ctrl-c-final-hook
                   'conditional-org-reveal-export-to-html))))

  (eval-after-load "org-toc-autoloads"
    '(progn
       (if (require 'org-toc nil t)
           (add-hook 'org-mode-hook 'org-toc-enable)
         (message "WARNING: org-toc not found"))))

  (eval-after-load "unfill-autoloads"
    '(progn
       (if (require 'unfill nil t)
           (define-key global-map [remap fill-paragraph]
             (defun fill-paragraph-dispatch (arg)
               "Fill or unfill paragraph"
               (interactive "P")
               (if arg
                   (if (region-active-p)
                       (unfill-region (region-beginning) (region-end))
                     (unfill-paragraph))
                 (fill-paragraph 'nil 't))))
         (message "WARNING: unfill not found"))))

  (eval-after-load "smex-autoloads"
    '(progn
       (if (require 'smex nil t)
           (progn
             (smex-initialize)
             (global-set-key (kbd "M-x") 'smex))
         (message "WARNING: smex not found"))))

  (eval-after-load "window-numbering-autoloads"
    '(progn
       (if (require 'window-numbering nil t)
           (window-numbering-mode 1)
         (message "WARNING: window-numbering-mode not found"))))

  ;; expand-region
  (eval-after-load "expand-region-autoloads"
    '(progn
       (when (require 'expand-region nil t)
         (add-hook 'text-mode-hook
                   '(lambda ()
                      (setq-local er/try-expand-list
                                  (remove 'er/mark-method-call er/try-expand-list))))

         (global-set-key (kbd "C-=") 'er/expand-region)
         (setq expand-region-fast-keys-enabled nil))))

  ;; multiple cursors
  (eval-after-load "multiple-cursors-autoloads"
    '(progn
       (when (require 'multiple-cursors nil t)
         (defun mc/mark-all-dispatch ()
           "- add a fake cursor at current position

  - call mc/edit-lines if multiple lines are marked

  - call mc/mark-all-like-this if marked region is on a single line"
           (interactive)
           (cond
            ((not (region-active-p))
             (mc/create-fake-cursor-at-point)
             (mc/maybe-multiple-cursors-mode))
            ((> (- (line-number-at-pos (region-end))
                   (line-number-at-pos (region-beginning))) 0)
             (mc/edit-lines))
            (t
             (mc/mark-all-like-this))))

         (defun mc/align ()
           "Aligns all the cursor vertically."
           (interactive)
           (let ((max-column 0)
                 (cursors-column '()))
             (mc/for-each-cursor-ordered
              (mc/save-excursion
               (goto-char (overlay-start cursor))
               (let ((cur (current-column)))
                 (setq cursors-column (append cursors-column (list cur)))
                 (setq max-column (if (< max-column cur) cur max-column)))))

             (defun mc--align-insert-times ()
               (interactive)
               (dotimes (_ times)
                 (insert " ")))

             (mc/for-each-cursor-ordered
              (let ((times (- max-column (car cursors-column))))
                (mc/execute-command-for-fake-cursor 'mc--align-insert-times cursor))
              (setq cursors-column (cdr cursors-column)))))

         (setq mc/list-file "~/.mc-lists.el")
         (load mc/list-file t) ;; load, but no errors if it does not exist yet please

         (global-set-key (kbd "C->")  'mc/mark-next-like-this)
         (global-set-key (kbd "C-<")  'mc/mark-previous-like-this)

         (global-set-key (kbd "M-@") 'mc/mark-all-dispatch)
         (global-set-key (kbd "M-#") 'mc/insert-numbers)
         (global-set-key (kbd "M-'") 'mc/align))))

  ;; browse-kill-ring
  (eval-after-load "browse-kill-ring-autoloads"
    '(progn
       (when (require 'browse-kill-ring nil t)
         (global-set-key (kbd "C-x C-y") 'browse-kill-ring)
         (define-key browse-kill-ring-mode-map (kbd "C-c C-k") 'browse-kill-ring-quit)
         (define-key browse-kill-ring-mode-map (kbd "C-x C-k") 'browse-kill-ring-quit)
         (define-key browse-kill-ring-mode-map (kbd "C-x k") 'browse-kill-ring-quit)
         (setq browse-kill-ring-quit-action 'save-and-restore))))

  ;; paredit
  (eval-after-load "paredit-autoloads"
    '(progn
       (when (require 'paredit nil t)
         (global-set-key (kbd "C-S-h") 'paredit-splice-sexp))))

  ;; wgrep
  (eval-after-load "wgrep-autoloads"
    '(progn
       (when (require 'wgrep nil t)
         (setq wgrep-enable-key "\C-x\C-q")
         (add-hook 'grep-mode-hook
                   '(lambda ()
                      (define-key grep-mode-map "\C-c\C-c"
                        'wgrep-save-all-buffers))))))

  (eval-after-load "yasnippet-autoloads"
    '(progn
       (if (require 'yasnippet nil t)
           (progn
             (let ((yas-dir "~/.yasnippets"))
               (when (file-exists-p yas-dir)
                 (setq yas-snippet-dirs (list yas-dir))))
             (yas-global-mode 1))
         (message "WARNING: yasnippet not found"))))

  ;; ox-reveal
  ;; export .org files as reveal.js presentations (https://github.com/hakimel/reveal.js/)
  (require 'ox-reveal nil t)

  ;; ------------------------------------------------------------
  ;; MATH DEFUNS

  (defun deg2rad (x)
    "Converts degrees to radians"
    (/ (* x float-pi) 180.0))

  (defun rad2deg (x)
    "Converts radians to degrees"
    (/ (* x 180.0) float-pi))

  (defun fov2focal (fov)
    "Evaluates dimensionless focal length given fov in radians"
    (/ 1.0 (tan (/ fov 2.0))))

  (defun focal2fov (fov)
    "Evaluates fov in radians given dimensionless focal length"
    (* 2.0 (atan (/ 1.0 fov))))

  ;; ------------------------------------------------------------
  ;; DEFUNS

  (defmacro url-do-it (backend-name query-beginning docstring)
    `(defun ,(intern (format "%s-it" (mapconcat 'identity (split-string (downcase backend-name)) "-"))) ()
       ,(format "%s the selected region if any, display a query prompt otherwise" docstring)
       (interactive)
       (browse-url
        (concat
         ,query-beginning
         (url-hexify-string (if mark-active
                                (buffer-substring (region-beginning) (region-end))
                              (read-string (concat ,backend-name ": "))))))))

  (global-set-key (kbd "\C-cg") (url-do-it "Google" "http://www.google.com/search?ie=utf-8&oe=utf-8&q=" "Google"))
  (global-set-key (kbd "\C-cl") (url-do-it "Lingvo" "http://lingvopro.abbyyonline.com/en/Translate/en-ru/" "Translate (using Lingvo)"))
  (global-set-key (kbd "\C-cu") (url-do-it "Urban Dictionary" "http://www.urbandictionary.com/define.php?term=" "Find a definition in Urban Dictionary for"))

  (defun increment-decimal-number-at-point (&optional arg)
    "Increment the number at point by `arg'."
    (interactive "p*")
    (save-excursion
      (save-match-data
        (let (inc-by field-width answer)
          (setq inc-by (if arg arg 1))
          (skip-chars-backward "0123456789")
          (when (re-search-forward "[0-9]+" nil t)
            (setq field-width (- (match-end 0) (match-beginning 0)))
            (setq answer (+ (string-to-number (match-string 0) 10) inc-by))
            (when (< answer 0)
              (setq answer (+ (expt 10 field-width) answer)))
            (replace-match (format (concat "%0" (int-to-string field-width) "d")
                                   answer)))))))

  (defun parent-directory (dir)
    "Returns parent directory of dir"
    (when dir
      (file-name-directory (directory-file-name (expand-file-name dir)))))

  (defun search-file-up (name &optional path)
    "Searches for file `name' in parent directories recursively"
    (let* ((file-name (concat path name))
           (parent (parent-directory path))
           (path (or path default-directory)))
      (cond
       ((file-exists-p file-name) file-name)
       ((string= parent path) nil)
       (t (search-file-up name parent)))))

  (defun add-sudo-to-filename (filename)
    "Adds sudo proxy to filename for use with TRAMP.

  Works for both local and remote hosts (>=23.4). The syntax used
  for remote hosts follows the pattern
  '/ssh:you@remotehost|sudo:remotehost:/path/to/file'. Some people
  say, that you may need to call smth like
  `(set-default 'tramp-default-proxies-alist (quote ((\".*\"
  \"\\`root\\'\" \"/ssh:%u@%h:\"))))', but it works for me just fine
  without it. "
    (with-temp-buffer
      (insert filename)
      (end-of-buffer)
      (if (re-search-backward "@\\(.*\\):" nil t)
          (let ((remote-name (buffer-substring (match-beginning 1) (match-end 1))))
            (goto-char (match-end 1))
            (insert (concat "|sudo:" remote-name))
            (beginning-of-buffer)
            (forward-char)
            (when (looking-at "scpc")
              (delete-char 4)
              (insert "ssh"))
            (buffer-string))
        (concat "/sudo::" filename))))

  (defun update-tags-file (arg)
    "Suggests options to update the TAGS file via ctags.

  With prefix arg - makes a call as sudo. Works for remote hosts
  also (>=23.4)"
    (interactive "P")
    (let ((tags-file-name
           (read-file-name
            "TAGS file: " (let ((fn (search-file-up "TAGS" default-directory)))
                            (if fn
                                (parent-directory fn)
                              default-directory))
            nil nil "TAGS"))
          (ctags-command "")
          (languages (case major-mode
                       ((cc-mode c++-mode c-mode) "--languages=C,C++")
                       ((d-mode) "--languages=D")
                       (t ""))))
      (when tags-file-name
        (setq ctags-command (concat ctags-command "cd " (replace-regexp-in-string ".*:" "" (file-name-directory tags-file-name)) " && ")))

      (setq ctags-command (concat ctags-command "ctags -e " languages " -R . "))

      (with-temp-buffer
        (when arg
          (cd (add-sudo-to-filename (expand-file-name default-directory))))
        (shell-command (read-from-minibuffer "ctags command: "  ctags-command)))
      (visit-tags-table tags-file-name)))

  (defun sudo-edit-current-file (&optional arg)
    "Edit currently visited file as root.

  With a prefix ARG prompt for a file to visit.
  Will also prompt for a file to visit if current
  buffer is not visiting a file."
    (interactive "P")
    (if (or arg (not buffer-file-name))
        (find-file (concat "/sudo:root@localhost:"
                           (ido-read-file-name "Find file(as root): ")))
      (let ((position (point)))
        (find-alternate-file (add-sudo-to-filename buffer-file-name))
        (goto-char position))))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; term
  (when (require 'term)

    (defadvice ido-switch-buffer (after maintain-ansi-term activate)
      "Go to prompt when switched to ansi-term"
      (when (member major-mode '(term-mode))
        (term-line-mode)
        (end-of-buffer)
        (end-of-line)
        (term-char-mode)))

    (defcustom term-remote-hosts '()
      "List of remote hosts")

    (defcustom ssh-config-filename "~/.ssh/config"
      "ssh config filename")
    (defun term-parse-ssh-config ()
      "Parse `ssh-config-filename' to provide `remote-term'
  completion capabilities."
      (interactive)
      (setq term-remote-hosts '())
      (if (file-exists-p ssh-config-filename)
          (with-temp-buffer
            (find-file ssh-config-filename)
            (goto-char (point-min))
            (while (re-search-forward "Host\\s-+\\([^\s]+\\)$" nil t)
              (let ((host (match-string-no-properties 1)))
                (add-to-list 'term-remote-hosts `(,host "ssh" ,host))))
            (kill-buffer))))
    (term-parse-ssh-config)

    (defun remote-term-do (new-buffer-name cmd &rest switches)
      "Fires a remote terminal"
      (setq term-ansi-buffer-name (concat "*" new-buffer-name "*"))
      (setq term-ansi-buffer-name (generate-new-buffer-name term-ansi-buffer-name))
      (setq term-ansi-buffer-name (apply 'term-ansi-make-term term-ansi-buffer-name cmd nil switches))
      (set-buffer term-ansi-buffer-name)
      (term-mode)
      (term-char-mode)
      (term-set-escape-char ?\C-x)
      (switch-to-buffer term-ansi-buffer-name))

    (defun remote-term (host-name)
      (interactive
       (list (completing-read "Remote host: " term-remote-hosts)))
      (dolist (known-host term-remote-hosts)
        (when (equal (car known-host) host-name)
          (apply 'remote-term-do known-host))))

    (add-hook 'term-mode-hook
              '(lambda ()
                 (yas-minor-mode -1)))

    (define-key term-mode-map "\C-x\C-j"   'dired-jump-universal-other)
    (define-key term-raw-escape-map "\C-j" 'dired-jump-universal-other)
    (define-key term-raw-escape-map "\C-l" 'term-line-mode)
    (define-key term-mode-map "\C-x\C-k"   'term-char-mode))
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ;; functions to save and restore window configuration for ediff-mode
  (defun ediff-save-window-configuration ()
    (window-configuration-to-register ?E))
  (defun ediff-restore-window-configuration ()
    (jump-to-register ?E))

  (defun swap-buffers-in-windows ()
    "Put the buffer from the selected window in next window"
    (interactive)
    (let* ((this (selected-window))
           (other (next-window))
           (this-buffer (window-buffer this))
           (other-buffer (window-buffer other)))
      (set-window-buffer other this-buffer)
      (set-window-buffer this other-buffer)
      (select-window other)               ;; comment to stay in current window
      )
    )

  (defun double-quote-word ()
    "Put word at point in double quotes"
    (interactive)
    (setq boundaries (bounds-of-thing-at-point 'word))
    (save-excursion
      (goto-char (car boundaries))
      (insert ?\")
      (goto-char (+ 1 (cdr boundaries)))
      (insert ?\")))

  (defun show-file-name ()
    "Show the full path file name in the minibuffer and add it to kill ring"
    (interactive)
    (message (buffer-file-name))
    (kill-new (buffer-file-name)))

  (define-key global-map [remap open-line]
    (defun open-line-indent (arg)
      "Use newline-and-indent in open-line command if there are
  non-whitespace characters after the point"
      (interactive "P")
      (save-excursion
        (if (looking-at-p "\\s-*$") ;; how in earth does this work?
            (newline arg)
          (newline-and-indent)))))

  (defun toggle-window-split ()
    "Switches from a horizontal split to a vertical split and vice versa."
    (interactive)
    (if (= (count-windows) 2)
        (let* ((this-win-buffer (window-buffer))
               (next-win-buffer (window-buffer (next-window)))
               (this-win-edges (window-edges (selected-window)))
               (next-win-edges (window-edges (next-window)))
               (this-win-2nd (not (and (<= (car this-win-edges)
                                           (car next-win-edges))
                                       (<= (cadr this-win-edges)
                                           (cadr next-win-edges)))))
               (splitter
                (if (= (car this-win-edges)
                       (car (window-edges (next-window))))
                    'split-window-horizontally
                  'split-window-vertically)))
          (delete-other-windows)
          (let ((first-win (selected-window)))
            (funcall splitter)
            (if this-win-2nd (other-window 1))
            (set-window-buffer (selected-window) this-win-buffer)
            (set-window-buffer (next-window) next-win-buffer)
            (select-window first-win)
            (if this-win-2nd (other-window 1))))))

  (defun notify-send (title msg &optional icon)
    "Show a popup; TITLE is the title of the message, MSG is the
  context. ICON is the optional filename or keyword.
  Portable keywords are: error, important, info."
    (interactive)
    (if (or (eq window-system 'x)
            (eq window-system 'w32))
        (save-window-excursion
          (async-shell-command (concat "notify-send "
                                       (if icon (concat "-i " icon) "-i important")
                                       " \"" title "\" \"" msg "\"")))
      ;; text only version
      (message (concat title ": " msg))))

  (defcustom git-grep-switches "--extended-regexp -I -n --ignore-case "
    "Switches to pass to 'git grep'."
    :type 'string)

  (defun git-grep (re)
    (interactive
     (list (let ((gg-init-value
                  ;; if region is active - use its value as an init
                  (if (region-active-p)
                      (buffer-substring-no-properties (region-beginning) (region-end))
                    nil)))
             (read-from-minibuffer "git grep: " gg-init-value nil nil 'grep-history))))
    (let ((grep-use-null-device nil))
      (grep (format "git --no-pager grep %s -e %s -- %s"
                    git-grep-switches
                    re
                    (expand-file-name (vc-git-root default-directory))))))

  (defun grep-dispatch (arg)
    "With prefix calls `git-grep' and `find-grep' otherwise"
    (interactive "P")
    (if arg
        (call-interactively 'git-grep)
      (call-interactively 'find-grep)))

  (defvar hs-hide-all-toggle-state nil "Current state of hideshow for toggling all.")
  (make-variable-buffer-local 'hs-hide-all-toggle-state)
  (defun hs-toggle-hideshow-all (arg)
    "Toggle hideshow all. Prefix arg is the level of hiding."
    (interactive "P")
    (if (not arg)
        (setq arg 1))
    (setq hs-hide-all-toggle-state (not hs-hide-all-toggle-state))
    (if hs-hide-all-toggle-state
        (hs-hide-level arg)
      (hs-show-all)))

  (defun eval-and-replace ()
    "Replace the preceding sexp with its value."
    (interactive)
    (backward-kill-sexp)
    (condition-case nil
        (prin1 (eval (read (current-kill 0)))
               (current-buffer))
      (error (message "Invalid expression")
             (insert (current-kill 0)))))

  (defmacro action-dispatch (action)
    `(defun ,(intern (format "%s-dispatch" action)) (arg)
       "Perform action on word or region."
       (interactive "P")
       (if (region-active-p)
           (,(intern (format "%s-region" action)) (region-beginning) (region-end))
         (,(intern (format "%s-word" action)) (if arg arg 1)))))

  (define-key global-map [remap upcase-word]     (action-dispatch upcase))
  (define-key global-map [remap downcase-word]   (action-dispatch downcase))
  (define-key global-map [remap capitalize-word] (action-dispatch capitalize))

  (defun eval-dispatch (arg)
    "Evaluate previous sexp or region"
    (interactive "P")
    (if (region-active-p)
        (let ((edebug-all-forms arg))
          (eval-region (region-beginning) (region-end) t))
      (eval-and-replace)))

  ;; move text
  (defun move-text-internal (arg)
    (cond
     ((and mark-active transient-mark-mode)
      (if (> (point) (mark))
          (exchange-point-and-mark))
      (let ((column (current-column))
            (text (delete-and-extract-region (point) (mark))))
        (forward-line arg)
        (move-to-column column t)
        (set-mark (point))
        (insert text)
        (exchange-point-and-mark)
        (setq deactivate-mark nil)))
     (t
      (let ((column (current-column)))
        (beginning-of-line)
        (when (or (> arg 0) (not (bobp)))
          (forward-line)
          (when (or (< arg 0) (not (eobp)))
            (transpose-lines arg))
          (forward-line -1))
        (move-to-column column t)))))

  (defun move-text-down (arg)
    "Move region (transient-mark-mode active) or current line
    arg lines down."
    (interactive "*p")
    (move-text-internal arg))

  (defun move-text-up (arg)
    "Move region (transient-mark-mode active) or current line
    arg lines up."
    (interactive "*p")
    (move-text-internal (- arg)))

  (defun join-following-line ()
    "Joins the following line"
    (interactive)
    (join-line -1))

  (defcustom pop-predefined-register ?}
    "Register for saving window configuration before jump"
    :type 'register)

  (define-key global-map [remap jump-to-register]
    (defun jump-to-register-with-save (register &optional delete)
      "Like jump-to-register, but saves current window configuration
  to predefined register"
      (interactive "cJump to register: \nP")
      ;; autosave current window configuration unless we're jumping back
      (unless (equal register pop-predefined-register)
        (window-configuration-to-register pop-predefined-register))
      (jump-to-register register delete)))

  (defun replace-path-with-truename ()
    "Replaces the region or the path around point with its true name.

  To get the true name it follows the symbolic links and converts
  relative paths to absolute."
    (interactive)
    (let (bds p1 p2 inputStr resultStr)
      ;; get current selection or filename
      (if (region-active-p)
          (setq bds (cons (region-beginning) (region-end) ))
        (setq bds (bounds-of-thing-at-point 'filename)))
      (setq p1 (car bds))
      (setq p2 (cdr bds))

      ;; grab the string
      (setq fn (buffer-substring-no-properties p1 p2)  )

      (if (file-exists-p fn)
          (progn
            (delete-region p1 p2 )
            (insert (file-truename fn)))
        (message "Path \"%s\" doesn't exist" fn))))

  (defun find-function-push-tag (function)
    "This function is meant as a drop-in replacement for find-tag
  in emacs-lisp-mode. It calls find-function and inserts current
  position into find-tag-marker-ring."
    (require 'etags)
    (interactive (find-function-read))
    (ring-insert find-tag-marker-ring (point-marker))
    (find-function function))

  ;; ------------------------------------------------------------
  ;; CUSTOMIZED

  (custom-set-variables
   ;; custom-set-variables was added by Custom.
   ;; If you edit it by hand, you could mess it up, so be careful.
   ;; Your init file should contain only one such instance.
   ;; If there is more than one, they won't work right.
   '(async-shell-command-buffer (quote new-buffer))
   '(c-basic-offset 4)
   '(c-default-style (quote ((c-mode . "bsd") (c++-mode . "bsd") (d-mode . "bsd") (java-mode . "java") (awk-mode . "awk") (other . "gnu"))))
   '(calendar-week-start-day 1)
   '(compilation-scroll-output (quote first-error))
   '(confirm-kill-emacs (quote y-or-n-p))
   '(create-lockfiles nil)
   '(default-input-method "russian-computer")
   '(diff-update-on-the-fly nil)
   '(ediff-before-setup-hook (quote (ediff-save-window-configuration)))
   '(ediff-highlight-all-diffs t)
   '(ediff-quit-hook (quote (ediff-cleanup-mess ediff-restore-window-configuration exit-recursive-edit)))
   '(ediff-split-window-function (quote split-window-horizontally))
   '(ediff-suspend-hook (quote (ediff-default-suspend-function ediff-restore-window-configuration)))
   '(ediff-window-setup-function (quote ediff-setup-windows-plain))
   '(fill-column 80)
   '(frame-background-mode (quote dark))
   '(grep-find-command (quote ("find . -type f -exec grep -nHi -e  {} +" . 35)))
   '(hippie-expand-try-functions-list (quote (try-complete-file-name-partially try-complete-file-name try-expand-all-abbrevs try-expand-dabbrev try-expand-dabbrev-all-buffers try-expand-dabbrev-from-kill)))
   '(ido-enable-flex-matching t)
   '(ido-mode (quote both) nil (ido))
   '(indent-tabs-mode nil)
   '(initial-major-mode (quote emacs-lisp-mode))
   '(initial-scratch-message nil)
   '(ls-lisp-dirs-first t)
   '(ls-lisp-ignore-case t)
   '(ls-lisp-verbosity nil)
   '(org-agenda-files (quote ("~/Dropbox/Private/org/")))
   '(org-clock-mode-line-total (quote current))
   '(org-confirm-babel-evaluate nil)
   '(org-directory "~/Dropbox/Private/org")
   '(org-hide-leading-stars t)
   '(org-modules (quote (org-bbdb org-bibtex org-docview org-gnus org-info org-jsinfo org-habit org-irc org-mew org-mhe org-rmail org-vm org-wl org-w3m)))
   '(org-src-fontify-natively t)
   '(org-startup-indented t)
   '(org-support-shift-select (quote always))
   '(read-buffer-completion-ignore-case t)
   '(read-file-name-completion-ignore-case t)
   '(scroll-conservatively 1)
   '(scroll-error-top-bottom t)
   '(show-paren-delay 0)
   '(tab-width 4)
   '(tags-case-fold-search nil)
   '(truncate-lines t)
   '(whitespace-style (quote (face tabs trailing space-before-tab newline indentation empty space-after-tab tab-mark newline-mark)))
   '(yas-prompt-functions (quote (yas-dropdown-prompt yas-ido-prompt yas-completing-prompt yas-x-prompt yas-no-prompt))))
  (custom-set-faces
   ;; custom-set-faces was added by Custom.
   ;; If you edit it by hand, you could mess it up, so be careful.
   ;; Your init file should contain only one such instance.
   ;; If there is more than one, they won't work right.
   '(diff-added ((t (:foreground "green"))))
   '(diff-file-header ((t (:background "black" :weight bold))))
   '(diff-header ((t (:background "black"))))
   '(diff-refine-change ((t (:background "dark slate gray"))))
   '(diff-removed ((t (:foreground "tomato"))))
   '(ediff-current-diff-A ((t (:background "white" :foreground "black"))) t)
   '(ediff-current-diff-Ancestor ((t (:background "white" :foreground "black"))) t)
   '(ediff-current-diff-B ((t (:background "white" :foreground "black"))) t)
   '(ediff-current-diff-C ((t (:background "white" :foreground "black"))) t)
   '(ediff-even-diff-A ((t (:background "antique white" :foreground "Black"))) t)
   '(ediff-even-diff-Ancestor ((t (:background "antique white" :foreground "black"))) t)
   '(ediff-even-diff-B ((t (:background "antique white" :foreground "black"))) t)
   '(ediff-even-diff-C ((t (:background "antique white" :foreground "Black"))) t)
   '(ediff-fine-diff-A ((t (:background "gainsboro" :foreground "blue"))) t)
   '(ediff-fine-diff-Ancestor ((t (:background "gainsboro" :foreground "red"))) t)
   '(ediff-fine-diff-B ((t (:background "gainsboro" :foreground "forest green"))) t)
   '(ediff-fine-diff-C ((t (:background "gainsboro" :foreground "purple"))) t)
   '(ediff-odd-diff-A ((t (:background "antique white" :foreground "black"))) t)
   '(ediff-odd-diff-Ancestor ((t (:background "antique white" :foreground "black"))) t)
   '(ediff-odd-diff-B ((t (:background "antique white" :foreground "Black"))) t)
   '(ediff-odd-diff-C ((t (:background "antique white" :foreground "black"))) t)
   '(term-color-black ((t (:background "#1d1f21" :foreground "#1d1f21"))))
   '(term-color-blue ((t (:background "#81a2be" :foreground "#81a2be"))))
   '(term-color-green ((t (:background "firebrick" :foreground "firebrick"))))
   '(term-color-magenta ((t (:background "#b294bb" :foreground "#b294bb"))))
   '(term-color-red ((t (:background "#cc6666" :foreground "#cc6666"))))
   '(term-color-white ((t (:background "#c5c8c6" :foreground "#c5c8c6"))))
   '(term-color-yellow ((t (:background "#f0c674" :foreground "#f0c674")))))

  ;; ------------------------------------------------------------
  ;; KEY BINDINGS

  ;; global
  (global-set-key (kbd "C-x f")       'find-file)
  (global-set-key [C-tab]             'ido-switch-buffer)
  (global-set-key (kbd "C-x C-q")     'view-mode)
  (global-set-key (kbd "C-M-p")       'backward-paragraph)
  (global-set-key (kbd "C-M-n")       'forward-paragraph)
  (global-set-key (kbd "\C-c c")      'org-capture)
  (global-set-key (kbd "\C-c a")      'org-agenda)
  (global-set-key (kbd "\C-x \C-b")   'ibuffer)
  (global-set-key (kbd "\C-x b")      'ibuffer)
  (global-set-key (kbd "M-p")         'move-text-up)
  (global-set-key (kbd "M-n")         'move-text-down)
  (global-set-key (kbd "M-P")         'scroll-down-line)
  (global-set-key (kbd "M-N")         'scroll-up-line)
  (global-set-key (kbd "\C-c s")      'swap-buffers-in-windows)
  (global-set-key (kbd "\C-c\C-s")    'swap-buffers-in-windows)
  (global-set-key (kbd "M-\"")        'double-quote-word)
  (global-set-key (kbd "\C-c w")      'show-file-name)
  (global-set-key (kbd "\C-x v a")    'vc-annotate)
  (global-set-key (kbd "\C-x v b")    'vc-annotate)
  (global-set-key (kbd "<f5>")        'revert-buffer)
  (global-set-key (kbd "\C-c f")      'toggle-window-split)
  (global-set-key (kbd "\C-c\C-f")    'toggle-window-split)
  (global-set-key [(control shift f)] 'grep-dispatch)
  (global-set-key (kbd "\C-x\C-e")    'eval-dispatch)
  (global-set-key (kbd "M-\\")        'fixup-whitespace)
  (global-set-key (kbd "C-M-h")       'backward-kill-word)
  (global-set-key (kbd "M-h")         'backward-kill-word)
  (global-set-key (kbd "M-/")         'hippie-expand)
  (global-set-key (kbd "\C-x k")      'kill-this-buffer)
  (global-set-key (kbd "C-+")         'org-list-repair)
  (global-set-key (kbd "M-+")         'org-list-repair)
  (global-set-key (kbd "C-x w")       'webjump)
  (global-set-key (kbd "C-x t")       'toggle-truncate-lines)
  (global-set-key (kbd "M-j")         'join-following-line)
  (global-set-key (kbd "M-Z")         'zap-up-to-char)
  (global-set-key (kbd "\C-x!")       'sudo-edit-current-file)
  (global-set-key (kbd "\C-c\C-o")    'find-file-at-point)
  (global-set-key (kbd "C-z")         'undo)
  (global-set-key (kbd "C-x /")       'replace-path-with-truename)
  (global-set-key [escape]            'keyboard-escape-quit)
  (global-set-key "\C-x\C-u"          'update-tags-file)
  (global-set-key "\C-x\C-v"          'visit-tags-table)
  (global-set-key "\C-x\C-t"          'tags-reset-tags-tables)
  (global-set-key "\C-x\C-l"          'tags-apropos)
  (global-set-key "\C-c\C-c"          'compile)
  (global-set-key "\C-c+"             'increment-decimal-number-at-point)

  ;; define translations
  (define-key key-translation-map [?\C-h] [?\C-?]) ;; translate C-h to DEL

  ;; C-/ is not representable with an ASCII control code, so it cannot be sent to
  ;; terminals, but it is a convenient keybinding for undo. So mapping it to
  ;; "traditional" undo sequence C-_ is a cute way around
  (define-key key-translation-map [?\C-/] [?\C-_]) ;; translate C-/ to C-_

  ;; convenient binding for C-x C-s in org-src-mode
  (add-hook 'org-src-mode-hook
            '(lambda ()
               (define-key org-src-mode-map (kbd "C-x C-s") 'org-edit-src-save)
               (define-key org-src-mode-map (kbd "C-x k")   'org-edit-src-exit)))

  (add-hook 'shell-mode-hook
            '(lambda ()
               (define-key shell-mode-map (kbd "\C-c\C-o") nil)))

  (add-hook 'org-mode-hook
            '(lambda ()
               ;; don't redefine some bindings
               (define-key org-mode-map [C-tab]
                 nil)
               (define-key org-mode-map (kbd "M-h")
                 nil)
               ;; swap active/inactive time-stamp bindings
               (define-key org-mode-map (kbd "C-c .")
                 'org-time-stamp-inactive)
               (define-key org-mode-map (kbd "C-c !")
                 'org-time-stamp)))

  (add-hook 'view-mode-hook
            '(lambda ()
               ;; simpler navigation
               (define-key view-mode-map "p"
                 'previous-line)
               (define-key view-mode-map "n"
                 'next-line)
               (define-key view-mode-map "f"
                 'forward-char)
               (define-key view-mode-map "b"
                 'backward-char)
               (define-key view-mode-map "l"
                 'recenter-top-bottom)
               (define-key view-mode-map "e"
                 'move-end-of-line)
               (define-key view-mode-map "a"
                 'smart-beginning-of-line)
               (define-key view-mode-map "v"
                 'scroll-up-command)))

  (add-hook 'conf-mode-hook
            '(lambda ()
               (define-key conf-mode-map "\C-c\C-c"
                 nil)))

  (add-hook 'sh-mode-hook
            '(lambda ()
               (define-key sh-mode-map "\C-c\C-c"
                 nil)
               (define-key sh-mode-map "\C-c\C-o"
                 nil)))

  (add-hook 'emacs-lisp-mode-hook
            '(lambda ()
               (define-key emacs-lisp-mode-map (kbd "M-.")
                 'find-function-push-tag)))

  (add-hook 'tar-mode-hook
            '(lambda ()
               (define-key tar-mode-map (kbd "g")
                 (defun revert-buffer-without-query ()
                   (interactive)
                   (revert-buffer nil t)))))

  (add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
  (add-to-list 'auto-mode-alist '("\\.c\\'" . c++-mode))
  (add-hook 'c-mode-common-hook
            '(lambda ()
               (define-key c-mode-base-map "\C-c\C-o"
                 'ff-find-other-file)

               (define-key c-mode-base-map "\C-c\C-c"    nil)
               (define-key c-mode-base-map (kbd "C-M-h") nil)
               (define-key c-mode-base-map (kbd "M-j")   nil)

               ;; hs-mode
               (hs-minor-mode t)
               (define-key c-mode-base-map "\C-ch"
                 'hs-toggle-hideshow-all)
               ;; set //-style comments for c-mode
               (setq comment-start "//" comment-end "")))

  (add-to-list 'auto-mode-alist '("\\.m\\'" . octave-mode))

  (add-to-list 'auto-mode-alist '("\\.abbrev_defs\\'" . emacs-lisp-mode))

  (add-to-list 'auto-mode-alist '("\\.log\\'" . auto-revert-tail-mode))

  ;; ------------------------------------------------------------
  ;; MISCELLANEOUS CONFIGS

  ;; write backup files to own directory
  (setq backup-directory-alist
        `(("." . ,(expand-file-name
                   (concat user-emacs-directory "backups")))))
  ;; make backups of files, even when they're under version control
  (setq vc-make-backup-files t)

  (require 'server)
  (when (equal window-system 'w32)
    ;; Suppress error "directory ~/.emacs.d/server is unsafe" on
    ;; windows.
    (defun server-ensure-safe-dir (dir) "Noop" t))

  ;; start emacs server on first run
  (unless (server-running-p) (server-start))
  ;; do not disturb with "buffer still has active clients" on buffer killing
  (remove-hook 'kill-buffer-query-functions 'server-kill-buffer-query-function)

  ;; ftp dumb hosts
  (setq ange-ftp-dumb-unix-host-regexp (regexp-opt '(
                                                     "files.itseez.com"
                                                     )))

  ;; disable 'confusing' functions disabling
  (put 'narrow-to-region 'disabled nil)

  ;; shut up the bell
  (setq ring-bell-function 'ignore)

  ;; ediff: fine highlight by char, not words
  (setq ediff-forward-word-function 'forward-char)

  ;; delete trailing whitespace before save
  (add-hook 'before-save-hook 'delete-trailing-whitespace)

  ;; show matching parentheses
  (show-paren-mode 1)

  ;; replace selection with input or yank
  (delete-selection-mode 1)

  ;; Show keystrokes in progress
  (setq echo-keystrokes 0.01)

  ;; Allow recursive minibuffers
  (setq enable-recursive-minibuffers t)

  ;; Revolt, outrage, revolution! No double spaces in the end of sentences.
  (set-default 'sentence-end-double-space nil)

  ;; make backspace to always delete chars
  (define-key isearch-mode-map [remap isearch-delete-char] 'isearch-del-char)
  (define-key isearch-mode-map [escape] 'isearch-cancel)

  ;; Answering just 'y' or 'n' will do
  (defalias 'yes-or-no-p 'y-or-n-p)

  ;; RecognizeCamelCaseSubwording
  (global-subword-mode)
  ;; don't remap some commands
  (define-key subword-mode-map (vector 'remap 'transpose-words) nil)
  (define-key subword-mode-map (vector 'remap 'upcase-word) nil)
  (define-key subword-mode-map (vector 'remap 'downcase-word) nil)
#+END_SRC
