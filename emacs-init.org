#+AUTHOR: Sergei Nosov
#+EMAIL: sergei.nosov@gmail.com

* Foreword

This is a little novel for casual reading about a text editor. Incidentally, it
also works as an Emacs 24.4 configuration file.

Every chapter talks about some aspect of my day-to-day Emacs usage. Hopefully,
you can find something useful for yourself and/or tell me about better ways to
do something in Emacs.

* Contents                                                   :noexport:TOC_1:
 - [[#foreword][Foreword]]
 - [[#ui-customization][UI customization]]
 - [[#text-manipulations][Text manipulations]]
 - [[#abbreviations][Abbreviations]]
 - [[#smarter-alternatives-to-built-in-functionality]["Smarter" alternatives to built-in functionality]]
 - [[#dired][Dired]]
 - [[#better-buffer-names][Better buffer names]]
 - [[#spelling-fly][Spelling fly]]
 - [[#fighting-escape-sequences-in-strings][Fighting escape sequences in strings]]
 - [[#parenthesis-for-dummies][Parenthesis for Dummies]]
 - [[#programming-languages][Programming languages]]
 - [[#magit][Magit]]
 - [[#ido-selection][Ido selection]]
 - [[#using-external-websites][Using external websites]]
 - [[#window-management][Window management]]
 - [[#embedded-lisp-evaluation][Embedded lisp evaluation]]
 - [[#field-applications][Field applications]]
 - [[#browse-kill-ring][Browse kill ring]]
 - [[#navigate-to-previous-position][Navigate to previous position]]
 - [[#get-full-path][Get full path]]
 - [[#multiple-cursors][Multiple cursors]]
 - [[#sudo-edit][Sudo edit]]
 - [[#ediff][Ediff]]
 - [[#term][Term]]
 - [[#grepping][Grepping]]
 - [[#hideshow-blocks][Hide/show blocks]]
 - [[#upcoming-sections][Upcoming sections]]
 - [[#unstructured-configuration][Unstructured configuration]]

* UI customization
** Lean and mean

Emacs doesn't need a lot of UI elements - it should be lean and mean. Well, and
clean. And it should look good on the screen.

#+BEGIN_SRC emacs-lisp
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (setq inhibit-startup-message t)
#+END_SRC

** Dark tango

For some reason, my eyes like dark background. Not pitch black, but pretty
black.

#+BEGIN_SRC emacs-lisp
  (funcall
   (defun configure-theme ()
     "Make Emacs pretty"
     (load-theme 'tango-dark)
     (enable-theme 'tango-dark)
     ;; make background a little bit darker
     (set-background-color "#1d1f21")))
#+END_SRC

** Deja Vu

DejaVu fonts family is simply the best one out there. And DejaVu Sans Mono is
the brightest child in the family:

- it's sans-serif
- it's mono-space
- it covers a great amount of Unicode symbols
- it's community-driven and MIT/public domain licensed
- it makes l, 1 and I clearly distinguishable, as well as 0 and O
- it's beautiful

Basically, DejaVu Sans Mono is a "font done right" for technical work.

#+BEGIN_SRC emacs-lisp
  (ignore-errors
    (set-frame-font
     (car (x-list-fonts "-*-DejaVu Sans Mono-normal-normal-normal-*-*-*-*-*-*-*-iso10646-1"))))
#+END_SRC

** Forbidden fruit

This section is supposed to make Emacs more usable on Mac's, but since I've
never owned a Mac, I can't really tell whether it works at all. If you own a
Mac, please, enlighten me!

#+BEGIN_SRC emacs-lisp
  (setq-default mac-command-modifier 'meta)
#+END_SRC

* Text manipulations

Some people mistakenly call Emacs a text editor. But, hey, what can you do -
total ignorance has become a common practice long time ago. And, frankly
speaking, these people have a point.

** Join following line

There's a default binding =M-^=, which takes the current line and puts in the
end of the previous one. A fell in love with it from the first day I came
across. But, actually, putting the next line in the end of the current one is a
better design for the same functionality.

#+BEGIN_SRC emacs-lisp
  (define-key global-map (kbd "M-j")
    (defun join-following-line ()
      "Joins the following line"
      (interactive)
      (join-line -1)))
#+END_SRC

** SubWords

CamelCaseIdentifiers are quite popular nowadays, so it's good to have an editor
which understands them. Emacs has a built-in support for that, so functions,
like, =forward-word=, =delete-word=, etc., will operate on subwords if minor
=subword-mode= is on.

It is quite handy and all, but, probably, half of the time you want to operate
on the whole identifier instead of the subword. I found that =expand-region=
nicely complements subword functionality in that regard:

- If you want to work with subwords, then use =M-f=, =M-b=, =M-d=, =M-h=, etc.
- Otherwise, use =C-== to select the whole word and do whatever you need.

#+BEGIN_SRC emacs-lisp
  (require 'subword)
  ;; RecognizeCamelCaseSubwording
  (global-subword-mode)
  ;; don't remap some commands
  (define-key subword-mode-map (vector 'remap 'transpose-words) nil)
  (define-key subword-mode-map (vector 'remap 'upcase-word) nil)
  (define-key subword-mode-map (vector 'remap 'downcase-word) nil)
#+END_SRC

** Backspace

Emacs has 2 bindings with slightly different meaning for the =Enter= key - =C-j=
and =C-m=. That's a good thing, because =Enter= is a frequently used, but pretty
distant key.

And you may wonder - what about =Backspace=? Why doesn't it have a better
binding as well?

I will tell you why. Because somebody stole it from us.

If you open a terminal emulator right now - most likely, you will find that
=C-h= acts as =Backspace=. It's a beautiful ancient tradition, but Emacs doesn't
follow it. And I state, that it is a result of some kind of sabotage in the
beginning of Emacs history. Don't believe me? Want evidence? You can check
everything yourself!

Clone an Emacs git repository and checkout the revision number
d7cc518448c8af66db86a842bbd0372e7e13a95a.

You'll find yourself in a distant 1988. That's a first time known by Emacs
revision history, when a =C-h= binding was mentioned.

Open the file =lisp/emulation/vip.el= and go to the line 217. You will find the
following, very suspicious code there:

#+BEGIN_EXAMPLE
  (defun vip-mode ()
    "Turn on VIP emulation of VI."
    (interactive)
    (if (not vip-inhibit-startup-message)
        (progn
      (switch-to-buffer "VIP Startup Message")
      (erase-buffer)
      (insert
       "VIP is a Vi emulation package for GNU Emacs.  VIP provides most Vi commands
  including Ex commands.  VIP is however different from Vi in several points.
  You can get more information on VIP by:
      1.  Typing `M-x info' and selecting menu item \"vip\".
      2.  Typing `C-h k' followed by a key whose description you want.
#+END_EXAMPLE

Pay attention to the first 2 lines of the code and to the very last one.

You see now? Those darn villains sabotaged Emacs just at the time, when they
understood that everything is finished for them. That they cannot hold a
competition against Emacs. So, they came up with their evil plan. And what a
disgusting, smug name for a mode - VIP.

Don't know about you, but I've seen enough evidence to be totally confident,
that it was a planned Vi fans demarche against Emacs. I can even assume, that
FBI and CIA were also involved. Which is the most likely reason, why Mr.
Stallman is so opposed to them.

But it's not the time for enjoying ourselves with this finding. It's time to
fight and restore justice! Time to take back what rightly belongs to us!

#+BEGIN_SRC emacs-lisp
  (define-key key-translation-map [?\C-h] [?\C-?]) ;; translate C-h to DEL
  (global-set-key (kbd "M-h")   'backward-kill-word)
  (global-set-key (kbd "C-M-h") 'backward-kill-word)
#+END_SRC

** Zap up to char

There's a nice binding =M-z=, which kills up to and including next occurrence of
the provided character.

But there's also an alternative function in the =misc= module, which kills up to
the provided character, EXCLUDING it. It is automatically bound to =M-Z= upon
=misc= module loading.

#+BEGIN_SRC emacs-lisp
  (require 'misc)
#+END_SRC

** Upcase, lowercase and capitalize

Since 99.999% of people using Emacs rebind Caps Lock to Ctrl, you need a decent
replacement for its use cases. Emacs has all the corresponding functionality,
but the bindings are pretty awkward. So I make it much easier to access:

- =M-u= - upcase word or region
- =M-l= - lowercase word or region
- =M-c= - capitalize word or region

#+BEGIN_SRC emacs-lisp
  (defmacro action-dispatch (action)
    `(defun ,(intern (format "%s-dispatch" action)) (arg)
       "Perform action on word or region."
       (interactive "P")
       (if (region-active-p)
           (,(intern (format "%s-region" action)) (region-beginning) (region-end))
         (,(intern (format "%s-word" action)) (if arg arg 1)))))

  (define-key global-map [remap upcase-word]     (action-dispatch upcase))
  (define-key global-map [remap downcase-word]   (action-dispatch downcase))
  (define-key global-map [remap capitalize-word] (action-dispatch capitalize))
#+END_SRC
** Move text

If you need to move text to some pretty distant place, then, of course, it's
easier to kill and yank it. But if you simply need to swizzle lines around a
bit, then =M-n= and =M-p= bindings are a natural way to think about it and do
it.

#+BEGIN_SRC emacs-lisp
  (defun move-text-internal (arg)
    (cond
     ((and mark-active transient-mark-mode)
      (if (> (point) (mark))
          (exchange-point-and-mark))
      (let ((column (current-column))
            (text (delete-and-extract-region (point) (mark))))
        (forward-line arg)
        (move-to-column column t)
        (set-mark (point))
        (insert text)
        (exchange-point-and-mark)
        (setq deactivate-mark nil)))
     (t
      (let ((column (current-column)))
        (beginning-of-line)
        (when (or (> arg 0) (not (bobp)))
          (forward-line)
          (when (or (< arg 0) (not (eobp)))
            (transpose-lines arg)
            ;; Account for changes to transpose-lines in Emacs 24.3
            (when (and (eval-when-compile
                         (not (version-list-<
                               (version-to-list emacs-version)
                               '(24 3 50 0))))
                       (< arg 0))
              (forward-line -1)))
          (forward-line -1))
        (move-to-column column t)))))

  (define-key global-map (kbd "M-p")
    (defun move-text-up (arg)
      "Move region (transient-mark-mode active) or current line arg
  lines up."
      (interactive "*p")
      (move-text-internal (- arg))))

  (define-key global-map (kbd "M-n")
    (defun move-text-down (arg)
      "Move region (transient-mark-mode active) or current line arg
  lines down."
      (interactive "*p")
      (move-text-internal arg)))
#+END_SRC
* Abbreviations

I have a collection of abbreviations for commands, that I use rarely enough to
forget their actual spelling, but often enough to get annoyed every time I have
to look it up somewhere.

As a simplest example, I always forget how to use the =ln= command to create a
symbolic link. Where do you have to put =-s=? Where is the target path and where
is the link name? I know, it's ridiculous, but I was making mistakes every time
I tried to use it.

Now, I simply print =ln=, hit =M-/= for =hippie-expand=, it becomes =ln -s
target link= and I'm happy.

The abbreviations are listed in =.abbrev_defs= file and, basically, all of those
are commands, which do something simple, but are represented by a random-looking
symbols sequence.

I also use =yasnippet= for a similar functionality, but it didn't work very well
in minibuffer for me. And since I use minibuffer to issue shell commands (=M-&=)
quite often, my rule of thumb is to use abbreviations for common shell commands
and =yasnippet= for everything else.

#+BEGIN_SRC emacs-lisp
  (when (require 'abbrev nil t)
    (add-hook 'find-file-hook
              '(lambda()
                 (abbrev-mode -1)))
    (setq-default abbrev-mode nil))
#+END_SRC

* "Smarter" alternatives to built-in functionality

The following functions try to be smarter about what they do, while closely
maintaining the original intent and implementation.

** Searching

If you select a region, that entirely lies on a single line, then incremental
searching (=C-s= and =C-r=) will use it as an initial value and make a first
jump. The common way I use it is:

- mark a word or a longer unit with =er/expand-region= (=C-==)
- press =C-s= or =C-r= to jump to the next or previous occurrence

#+BEGIN_SRC emacs-lisp
  (defmacro smart-isearch (direction)
    `(defun ,(intern (format "smart-isearch-%s" direction)) (&optional regexp-p no-recursive-edit)
       "If region is active and non empty, use it for searching and
    make first jump. Otherwise, behave like original function."
       (interactive "P\np")
       (let ((smart-p (and
                       (region-active-p)
                       (< (region-beginning) (region-end))
                       (= (- (line-number-at-pos (region-end))
                             (line-number-at-pos (region-beginning))) 0)
                       )))
         (when smart-p
           (kill-ring-save (region-beginning) (region-end)))

         (,(intern (format "isearch-%s" direction)) regexp-p no-recursive-edit)

         (when smart-p
           (isearch-yank-kill)
           (,(intern (format "isearch-repeat-%s" direction)))))))
  (define-key global-map [remap isearch-forward]  (smart-isearch forward))
  (define-key global-map [remap isearch-backward] (smart-isearch backward))
#+END_SRC

Similarly, =occur= (=M-s o=) will use the selected region, if any, without
prompting. By the way, you can press =M-s o= during incremental search to
call =occur= for the current search string.

#+BEGIN_SRC emacs-lisp
  (define-key global-map [remap occur]
    (defun smart-occur (arg)
      (interactive "P")
      (if (region-active-p)
          (occur (buffer-substring-no-properties (region-beginning) (region-end)) arg)
        (call-interactively 'occur))))
#+END_SRC

I got used to the convention of =C-x C-q= being a toggle between writable and
read-only buffer states. It's better for occur mode to follow this convention.

#+BEGIN_SRC emacs-lisp
  (define-key occur-mode-map "\C-x\C-q" 'occur-edit-mode)
  (define-key occur-edit-mode-map "\C-x\C-q" 'occur-cease-edit)
#+END_SRC

** Beginning of line

When jumping to the beginning of line, more often than not you actually want to
jump to the first non-whitespace character. So, the default behavior of
=beginning-of-line= (=C-a=) is remapped to =back-to-indentation=. In case you
actually wanted to go to the very beginning of the line, you should hit =C-a=
one more time.

#+BEGIN_SRC emacs-lisp
  (define-key global-map [remap move-beginning-of-line]
    (defun smart-beginning-of-line ()
      "Move point to first non-whitespace character or beginning-of-line.

    Move point to the first non-whitespace character on this line.
    If point was already at that position, move point to beginning of line."
      (interactive)
      (let ((oldpos (point)))
        (back-to-indentation)
        (and (= oldpos (point))
             (beginning-of-line)))))
#+END_SRC

** Free advice

It is so natural and convenient for the just yanked region to be properly
indented, that I got used to this functionality even before I turned it on. On
the rare occasions you can use universal argument to suppress auto indentation.

#+BEGIN_SRC emacs-lisp
  (defadvice insert-for-yank-1 (after indent-region activate)
    "Indent yanked region in certain modes, C-u prefix to disable"
    (if (and (not current-prefix-arg)
             (member major-mode '(sh-mode
                                  emacs-lisp-mode lisp-mode
                                  c-mode c++-mode objc-mode d-mode java-mode cuda-mode
                                  LaTeX-mode TeX-mode
                                  xml-mode html-mode css-mode)))
        (indent-region (region-beginning) (region-end) nil)))
#+END_SRC

** View mode

Emacs has a strange-looking convention for binding =C-x C-q= to toggle a
read-only state. It's not ubiquitous, but it's definitely the most common
binding. So, I try to follow it wherever it makes sense and customize the modes
that don't follow it.

However, I find that =view-mode= for most of the buffers provides a better
alternative to simple read-only toggle. It has some additional navigation
functions, and also, you can use shorter bindings (leaving the =C-= modifier)
for common operations.

There's some kind of Vimy flavor to it and, eventually, when I use it I find
myself thinking "How can those Vim people live switching between editing and
viewing modes all the time? Weirdest guys."

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-q") 'view-mode)

  ;; simpler navigation
  (define-key view-mode-map "p" 'previous-line)
  (define-key view-mode-map "n" 'next-line)
  (define-key view-mode-map "f" 'forward-char)
  (define-key view-mode-map "b" 'backward-char)
  (define-key view-mode-map "l" 'recenter-top-bottom)
  (define-key view-mode-map "e" 'move-end-of-line)
  (define-key view-mode-map "a" 'smart-beginning-of-line)
  (define-key view-mode-map "v" 'scroll-up-command)
#+END_SRC

** Fill/unfill paragraph

#+BEGIN_SRC emacs-lisp
  (setq-default fill-column 80)
#+END_SRC

=fill-paragraph= command (=M-q=) is so handy, that I find myself using it more
often, than =newline-and-indent= when writing text.

I tweaked it a bit, so that when you provide a universal argument, then the
paragraph (or region) is "unfilled", i.e. it's placed on a single line. It may
seem like a useless function, but it turns out to be pretty handy as well.

Consider a case, when you're writing an e-mail which is going to be posted to
some news group and displayed via web interface. If the width of the field for
your e-mail is lesser that your =fill-column= value, then it will look ugly.
E.g. you send the following text:

#+BEGIN_EXAMPLE
  This is not a very long sentence, but it's long enough to occupy 2 lines for your
  fill-column value.

  This is the next sentence, after the "not-so-long" one.
#+END_EXAMPLE

If the width of the displaying field is less than 80 (in my case), then it will
look something like this:

#+BEGIN_EXAMPLE
  This is not a very long sentence, but it's long enough to occupy
  2 lines for your
  fill-column value.

  This is the next sentence, after the "not-so-long" one.
#+END_EXAMPLE

You get those 2 short, ugly lines.

In order to workaround this, you can rely on the web interface (or any other
client, that will render an e-mail) and perform =unfill-region= before sending
it.

To do this, simply select the text and provide a universal argument: =C-u M-q=.

#+BEGIN_SRC emacs-lisp
  (eval-after-load "unfill-autoloads"
    '(progn
       (if (require 'unfill nil t)
           (define-key global-map [remap fill-paragraph]
             (defun fill-paragraph-dispatch (arg)
               "Fill or unfill paragraph"
               (interactive "P")
               (if arg
                   (if (region-active-p)
                       (unfill-region (region-beginning) (region-end))
                     (unfill-paragraph))
                 (fill-paragraph 'nil 't))))
         (message "WARNING: unfill not found"))))
#+END_SRC

* Dired

As you may know, dired stands for DIRectory EDitor and it is, basically, a file
manager inside Emacs.

I consider dired a truly amazing piece of software. More than anything, it makes
the job done without over-complication on implementation or interface side.

#+BEGIN_SRC emacs-lisp
  (require 'dired-x nil t)
#+END_SRC

** Dired jump
To enable a convenient =C-x C-j= binding, we have to require the =dired-x=
module. When visiting a file, =C-x C-j= opens current directory in dired. When
already in dired, it jumps to the parent directory. With universal argument -
=C-u C-x C-j= - it opens dired in other window.

Note, that in Dired and in View mode it is also bound to a nice shortcut - =j=.
So, if you want to traverse some tree and have a quick look into some files, you
can use one-letter commands for navigation. You only need to use =v= to open
files in =view-mode= and =j= - to jump back to dired.

#+BEGIN_SRC emacs-lisp
  (define-key dired-mode-map (kbd "j")
    (define-key global-map (vector 'remap 'dired-jump)
      (defun dired-jump-universal-other (arg)
        "Calls dired-jump. With prefix argument uses other window"
        (interactive "P")
        (dired-jump arg))))

  (define-key view-mode-map "j" 'dired-jump-universal-other)
#+END_SRC

** Dired details
=dired-details= module helps to hide a lot of unnecessary information inside
dired. You can toggle its visibility by pressing =h=:

#+BEGIN_SRC emacs-lisp
  (eval-after-load "dired-details-autoloads"
    '(progn
       (when (require 'dired-details nil t)
         (add-hook 'dired-mode-hook
                   '(lambda ()
                      (dired-details-install)
                      (setq dired-details-hidden-string "--- ")
                      (define-key dired-mode-map (kbd "h") 'dired-details-toggle))))))
#+END_SRC

** Dired async
=dired-async= module makes copying, renaming and deletion commands asynchronous:

#+BEGIN_SRC emacs-lisp
  (eval-after-load "async-autoloads"
    '(progn
       (if (require 'dired-async nil t)
           (progn
             (set-face-attribute 'dired-async-message nil
                                 :foreground nil
                                 :inherit 'mode-line-emphasis)
             (set-face-attribute 'dired-async-mode-message nil
                                 :background nil
                                 :inherit 'highlight))
         (message "WARNING: dired-async not found"))))
#+END_SRC

** Jumping back and forth
=beginning-of-buffer= and =end-of-buffer= commands should move the point to
better positions:

#+BEGIN_SRC emacs-lisp
  (define-key dired-mode-map (vector 'remap 'end-of-buffer)
    (defun dired-jump-to-bottom ()
      "Jumps to the last file"
      (interactive)
      (goto-char (point-max))
      (dired-previous-line 1)))

  (define-key dired-mode-map (vector 'remap 'beginning-of-buffer)
    (defun dired-jump-to-top ()
      "Jumps to the .. entry"
      (interactive)
      (goto-char (point-min))
      (dired-next-line 1)
      ;; skip another line depending on hidden/shown state of dired-details
      (with-no-warnings
        (when (or (not (boundp 'dired-details-state))
                  (equal dired-details-state 'shown))
          (dired-next-line 1)))
      (if (looking-at "\\.") ;; top-level directories don't have a
          ;; .. entry
          (dired-next-line 1))))
#+END_SRC

** Do what I mean

- If you have 2 dired windows opened, then copying and renaming should use the
  directory of the other window as a default target:

  #+BEGIN_SRC emacs-lisp
    (setq dired-dwim-target t)
  #+END_SRC

- Don't be afraid of recursive operations:

  #+BEGIN_SRC emacs-lisp
    (setq
     dired-recursive-copies (quote always)
     dired-recursive-deletes (quote always))
  #+END_SRC

- Group directories first:

  #+BEGIN_SRC emacs-lisp
    (setq dired-listing-switches
          (concat "-alh"
                  (when (not (equal window-system 'w32))
                    " --group-directories-first")))
  #+END_SRC

** Wdired

When editing dired buffer (=C-x C-q=), allow to change the permissions as well:

#+BEGIN_SRC emacs-lisp
  (define-key dired-mode-map (kbd "C-x C-q") 'dired-toggle-read-only)
  (setq-default wdired-allow-to-change-permissions t)
#+END_SRC

** Native explorer

Use =E= in dired to open a system's native file explorer in current directory:

#+BEGIN_SRC emacs-lisp
  (define-key dired-mode-map (kbd "E")
    (defun open-window-manager ()
      "Open default system windows manager in current directory"
      (interactive)
      (save-window-excursion
        (if (equal window-system 'w32)
            (async-shell-command "explorer .")
          (if (equal window-system 'x)
              (async-shell-command "nautilus ."))))))
#+END_SRC

** Tar (Tahr? Thar?)

One thing that makes me upset about Dired is its somewhat limited support for
compression. Yes, there's a =Z= key for this, but

- it doesn't compress directories
- when multiple files are marked, each file is compressed to a separate archive,
  which is not what I want in 98.6% of cases

For some reason Dired is not very customizable in that regard. At least, I
couldn't find a way to alter its behavior without a complete rewrite of related
functions.

So, I ended up with a small function which does what I want in 98.6% of cases.
You press =z=, and it asks you for an output archive name. If multiple files are
marked at the moment, it will compress those into a single archive. And,
surprisingly, it works for directories, too!

If I want to untar an archive, I simply use =&= which suggests untaring as a
first guess.

#+BEGIN_SRC emacs-lisp
  (define-key dired-mode-map (kbd "z")
    (defun dired-tar-marked-files ()
      "Ask a name for a .tar.gz archive and compress the marked
  files into it. If no files are marked or a numeric prefix arg is
  given, the next ARG files are used. Just C-u means the current
  file. The prompt mentions the file(s) or the marker, as
  appropriate."
      (interactive)
      (let* ((files (dired-get-marked-files t current-prefix-arg))
             (out-name (concat
                        (if (equal (length files) 1)
                            (file-name-nondirectory (car files))
                          (file-name-base (directory-file-name (expand-file-name default-directory))))
                        ".tar.gz")))
        (async-shell-command (concat
                              "tar -czvf "
                              (dired-mark-pop-up
                               nil 'shell files
                               'read-shell-command
                               (format "Output file name for 'tar -czvf' on %s: "
                                       (dired-mark-prompt current-prefix-arg files))
                               out-name nil)
                              " "
                              (mapconcat 'identity files " "))))))
#+END_SRC
* Better buffer names
** Default uniquification

If you open several files with the same name, then a good way to distinguish
between those is to prepend parent directory names to file names. If the names
still conflict, you can add another parent directory levels, until the clash is
resolved

#+BEGIN_SRC emacs-lisp
  (require 'uniquify)
  (setq-default uniquify-buffer-name-style 'forward)
#+END_SRC

** Append tramp host

For remote files, opened with TRAMP, it makes sense to append the hostname to
the buffer name.

#+BEGIN_SRC emacs-lisp
  (require 'tramp)
  (defun append-tramp-host ()
    "Appends host name to the current buffer name for remote
  files"
    (interactive)
    (when (tramp-tramp-file-p default-directory)
      (rename-buffer
       (concat
        (replace-regexp-in-string " <.*>$" "" (or (uniquify-buffer-base-name) (buffer-name)))
        " <"
        (tramp-file-name-host
         (tramp-dissect-file-name default-directory)) ">")
       t)))

  (add-hook 'find-file-hook 'append-tramp-host)
  (add-hook 'dired-mode-hook 'append-tramp-host)
#+END_SRC

** Rename buffer

In case you have a better name for a buffer, you can always rename it by
pressing =C-x C-r=.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "\C-x\C-r") 'rename-buffer)
#+END_SRC
* Spelling fly

Can't tell it for sure, but I suspect that even the brightest spelling bee
champions hit the wrong button once in a while. So, it's good to have an
automated spell-checking in every text buffer you edit.

It would be an overkill for editing source code, since everybody loves
identifiers like "src", "lhs", "rhs", "ptr", "uniq", "img", "gl", "qq" and a
gazillion of other pretty names. But, for that, we have a =flyspell-prog-mode=
which checks spelling only in strings and comments.

By default, only words under the cursor are checked for correctness. So, if you
want to spell check the whole buffer (or region), hit =C-x M-$=. When the cursor
is under the red-highlighted word, you can press =M-$= to look for alternative
spellings. To go to the next error, hit "C-,". To auto-correct the next word,
hit =C-.=.

I edit texts in both Russian and English and I have to spell-check both of the
languages. To toggle between those dictionaries I use =C-c M-$=. If you want to
toggle (cycle, actually) between (through) other languages, you can customize
the =ispell-common-dictionaries= variable.

#+BEGIN_SRC emacs-lisp
  (require 'flyspell)
  (add-hook 'text-mode-hook 'flyspell-mode)
  (add-hook 'prog-mode-hook 'flyspell-prog-mode)

  (defcustom ispell-common-dictionaries
    '("en" "ru")
    "List of dictionaries for common use"
    :group 'ispell)

  (setq-default ispell-dictionary (car ispell-common-dictionaries))

  (define-key flyspell-mode-map (kbd "C-c M-$")
    (defun ispell-next-dictionary()
      "Cycle through dictionaries in `ispell-common-dictionaries'"
      (interactive)
      (let* ((dic ispell-current-dictionary)
             (next (cadr (member dic ispell-common-dictionaries)))
             (change (if next next (car ispell-common-dictionaries))))
        (ispell-change-dictionary change))))

  (define-key flyspell-mode-map (kbd "C-x M-$")
    (defun flyspell-buffer-or-region ()
      (interactive)
      (if (region-active-p)
          (flyspell-region (region-beginning) (region-end))
        (flyspell-buffer))))
#+END_SRC
* Fighting escape sequences in strings

It is frustratingly difficult to follow special characters and sequences in
strings. Especially, in regular expressions, where you have 2 levels deep
languages hierarchy. This leads to strings, like, =\\\\= (4 backslashes) for
matching a =\= (single backslash).

With string-edit mode you can press =C-c e= to edit a string at point without
escape sequences, breaking one level of nesting.

To finish editing, press =C-c C-c=. To abort, press =C-c C-k=.

#+BEGIN_SRC emacs-lisp
  (eval-after-load "string-edit-autoloads"
    '(progn
       (if (require 'string-edit nil t)
           (progn
             (global-set-key "\C-ce" 'string-edit-at-point)
             (define-key string-edit-mode-map (vector 'remap 'kill-this-buffer) 'string-edit-abort))
         (message "WARNING: string-edit not found"))))
#+END_SRC

As a side note, for the particular case of editing regular expressions, you can
also use the command =M-x re-builder= to interactively construct highly
sophisticated expressions.

* Parenthesis for Dummies

I'm kind of ashamed to be the author of =dummyparens= mode. But I tried not to
be one really hard.

The thing is, I wanted a really simple auto-pairing functionality with only 2
requirements:

- after I press =(=, =[=, " or ={= it should behave like if I pressed the key of
  the corresponding closing pair immediately
- if the region is selected, when I press an opening symbol, it should be
  wrapped

Simple as that. Easiest thing in the world. But not only I didn't find a
built-in solution for that, I didn't find a decent solution to exist at all!

The first option was, obviously, =electric-pair=. It's built-in and
lightweight - great. But for some reason it doesn't insert the closing pair if
the following character is non-whitespace. It also doesn't support wrapping.

The next promising candidate was =autopair= supporting both auto-pairing and
wrapping. It was "almost there", but there were 2 reasons why I couldn't live
with it:

- It uses =insert= function to insert symbols and, generally speaking, it is not
  quite correct to do so. Like, for example, =cc-mode= has it's own binding for
  opening parenthesis - =c-electric-paren=, which sometimes indents the current
  line among other things. So, if you're using =autopair=, you're losing this
  behavior.
- And, kind of a follow-up, =autopair= was doing a lot of fancy stuff
  out-of-the-box and I constantly had to fight my way through to make it as
  unobtrusive as possible. And still, I kept encountering corner cases, when it
  tried to be smarter than it should.

Probably, after fighting long enough, I could make =autopair= work as I wanted
it to. But why fight so hard, if I knew I could implement the desired
functionality with much smaller effort?

Before I went on with =dummyparens=, my last try was =smartparens=. The
description was thoughtful and sensible. But when I tried it... The thing
actually puts an overlay on braces, has some notion of state and prints messages
to the echo area - and all of this for a pair of braces.

It was the point when I exclaimed "That does it! I'm writing my own auto-pairing
mode! With blackjack and wrapping!"

The key moments of the mode are:
- It's under 100 lines of code.
- When you press an opening pair key, it issues the exact same command as if the
  mode was off. Then it "presses" the closing pair key (i.e. issues the exact
  same command as if the mode was off)
- If the region is selected - it is wrapped.
- Optionally, it runs a "post-handler" hook, which can be any function you want.
  Personally, I have a single hook, enabled for curly braces (={=). It indents
  the just wrapped region - very convenient for the C-family languages.

I could easily fit these 100 lines of code in the configuration file. But I want
to believe, that I'm not mad. That somebody else might find this functionality
useful as well.

P.S. I have found more or less decent built-in solution after using
=dummyparens= for about 2 years. The solution was to use the
=skeleton-pair-insert-maybe= function. Unfortunately (or luckily), it fails
short the same way =autopair= does. It doesn't exactly "press" the keys, but
rather uses =self-insert-command=, which is not correct in general case. Also,
it has an annoying half-of-a-second delay after inserting the closing pair. And
it doesn't have the shiny auto-indentation functionality for ={=, which I became
addicted to over the years! And also... forget it, simply use =dummyparens= -
this whole topic isn't worth so many words. AND I'M NOT MAD!

#+BEGIN_SRC emacs-lisp
  (eval-after-load "dummyparens-autoloads"
    '(progn
       (if (require 'dummyparens nil t)
           (global-dummyparens-mode)
         (message "WARNING: dummyparens not found"))))
#+END_SRC

For the opposite functionality - removing parenthesis in pair - I use the
=C-S-h= binding, backed by the =paredit= mode. It has far more features and,
actually, provides a somewhat revolutionary way to edit Abstract Syntax Trees
(AST) directly. But I don't write a lot of Lisp and I even don't write a lot of
HTML. So, I don't have a strong need for that kind of editing power.

#+BEGIN_SRC emacs-lisp
  (eval-after-load "paredit-autoloads"
    '(progn
       (when (require 'paredit nil t)
         (global-set-key (kbd "C-S-h") 'paredit-splice-sexp))))
#+END_SRC

* Programming languages
** Compile

All I really need for programming is =C-c C-c= to issue =compile= command and
being able to jump to the line with the error from the compilation buffer.

The only nifty trick I find particularly useful is to make =compile-command=
variable buffer-local. After that each buffer will remember what compilation
command was issued from it and suggest it on the successive call.

This replaces all the "project management" nonsense for me. It's incredibly
flexible, convenient and simple at the same time. Truly, great stuff.

#+BEGIN_SRC emacs-lisp
  (require 'compile)
  (make-variable-buffer-local 'compile-command)
  ;; those patterns are used by dmd compiler
  (setq-default compilation-error-regexp-alist
                (append '(("^\\(.*?\\)(\\([0-9]+\\)): Warning:" 1 2 nil 1)
                          ("^\\(.*?\\)(\\([0-9]+\\)): Error:" 1 2 nil 2))
                        compilation-error-regexp-alist))
#+END_SRC
** Python

Probably, the most prominent package for Python development is =elpy=. At least
it was, when I checked last time. It has all the "cool kids" features:
auto-completion, refactoring, documentation access, etc.

Personally, I don't find those features to be a big deal. So, when =elpy=
explicitly refused to work on a remote python script, I removed it without
second thought.

I also don't really need a shell (or REPL), since I'm not used to interpreters.
But if I'm to pick one for Python, it will, obviously, be =ipython=.

#+BEGIN_SRC emacs-lisp
  (when (require 'python nil t)
    (if (executable-find "ipython")
        (setq-default
         python-shell-interpreter "ipython"
         python-shell-prompt-regexp "In \\[[0-9]+\\]: "
         python-shell-prompt-output-regexp "Out\\[[0-9]+\\]: "))

    (add-hook 'python-mode-hook
              '(lambda ()
                 (define-key python-mode-map (kbd "\C-c\C-c") 'compile)
                 (define-key python-mode-map (kbd "\C-c\C-e") 'python-shell-send-buffer))))
#+END_SRC

** Markdown

In my opinion, =markdown-mode= is somewhat overwhelming in its functionality. It
binds too many combinations to the extent when it starts to feel obtrusive.

If I were to implement a Markdown mode, I would try to mimic it as closely to
=org-mode= as possible. But, apparently, =markdown-mode= authors have another
point of view, so the mode is different in almost everything it does.

So, the only things, that I actually use in this mode is syntax highlighting and
a =markdown-export= function (=C-c C-e=).

#+BEGIN_SRC emacs-lisp
  (eval-after-load "markdown-mode-autoloads"
    '(progn
       (if (require 'markdown-mode nil t)
           (progn
             (setq auto-mode-alist (cons '("\\.md" . markdown-mode) auto-mode-alist))

             (define-key markdown-mode-map (kbd "M-p") nil)
             (define-key markdown-mode-map (kbd "M-n") nil)
             (define-key markdown-mode-map (kbd "\C-c\C-c") nil)
             (define-key markdown-mode-map (kbd "\C-c\C-e") 'markdown-export))
         (message "WARNING: markdown-mode not found"))))
#+END_SRC

** D

The only unusual thing about this mode is that it alters the default syntax
indentation. It lines up the dots in situations, like

#+BEGIN_EXAMPLE
  foreach (file; dirPath.expandTilde()
                        .buildNormalizedPath()
                        .dirEntries(SpanMode.shallow)()
#+END_EXAMPLE

There's kind of a funny story around this functionality. Somebody asked a
[[https://stackoverflow.com/questions/25797945/adjusting-alignment-rules-for-ucfs-chains-in-d][question]] on StackOverflow about how you can achieve this. I got interested and
started to dig.

Surprisingly, there was a built-in function for that, called
=c-lineup-cascaded-calls=, so you all you had to do is to put it in the right
place. But where is that place?

Turns out there's a =c-offsets-alist= variable, which contains the indentation
rules in the following format: =(<applicable place> . <rule>)=. Here,
=<applicable place>= stands for a keyword understood by the C indentation
engine, like =statement-cont= (continuation of the statement).

So far, so good. The =statement-cont= keyword worked like a charm. But it didn't
work for the particular case from the question. Apparently, there was some other
keyword for that place and I had to find out what it was.

After a long trial and error session, I found out there's a variable
=c-echo-syntactic-information-p=. One can set it to =t= and on every indentation
call after that, the information about current position will be displayed in the
echo area.

The keyword I was looking for turned out to be =arglist-cont-nonempty=.

But it was only a half of the problem. The =c-lineup-cascaded-calls= function
didn't work in some important cases:

- when function calls didn't have any parenthesis (which are optional in D)
- when calling a function with compile-time parameters, e.g.
  =func!(compiletime)(runtime)=

I posted a dirty rewrite of =c-lineup-cascaded-calls= to the StackOverflow
answer and it went right down to the =d-mode= repository, so I had to enable it
in my setup. Not that I find this indentation strategy particularly useful, but
I don't feel like dropping it after putting so much effort into it.

#+BEGIN_SRC emacs-lisp
  (eval-after-load "d-mode-autoloads"
    '(progn
       (when (require 'd-mode nil t)
         (when (fboundp 'd-lineup-cascaded-calls)
           (add-hook 'd-mode-hook
                     '(lambda ()
                        (add-to-list 'c-offsets-alist '(arglist-cont-nonempty . d-lineup-cascaded-calls))
                        (add-to-list 'c-offsets-alist '(statement-cont . d-lineup-cascaded-calls)))))
         (setq auto-mode-alist
               (append '(("\\.d\\'" . d-mode)
                         ("\\.di\\'" . d-mode))
                       auto-mode-alist)))))
#+END_SRC

** Misc

Nothing special, really.

*** YAML

#+BEGIN_SRC emacs-lisp
  (eval-after-load "yaml-mode-autoloads"
    '(progn
       (if (require 'yaml-mode nil t)
           (add-to-list 'auto-mode-alist '("\\.yml$" . yaml-mode))
         (message "WARNING: yaml-mode not found"))))
#+END_SRC

*** CMake

#+BEGIN_SRC emacs-lisp
  (eval-after-load "cmake-mode-autoloads"
    '(progn
       (when (require 'cmake-mode nil t)
         (setq auto-mode-alist
               (append '(("CMakeLists\\.txt\\'" . cmake-mode)
                         ("CMakeCache\\.txt\\'" . cmake-mode)
                         ("\\.cmake\\'" . cmake-mode))
                       auto-mode-alist)))))
#+END_SRC

*** DOS

#+BEGIN_SRC emacs-lisp
  (eval-after-load "dos-autoloads"
    '(progn
       (when (require 'dos nil t)
         (setq auto-mode-alist
               (append '(("\\.cmd\\'" . dos-mode)
                         ("\\.bat\\'" . dos-mode))
                       auto-mode-alist)))))
#+END_SRC

* Magit

There's not enough words in any human language to describe the brilliance of
=magit=. So, let's simply take a minute and think about cosmic order of things
in silence.

#+BEGIN_SRC emacs-lisp
  (eval-after-load "magit-autoloads"
    '(progn
       (if (require 'magit nil t)
           (progn
             (require 'gitignore-mode nil t)
             (require 'gitconfig-mode nil t)
             (require 'gitattributes-mode nil t)

             (setq
              magit-revert-item-confirm nil
              magit-diff-refine-hunk t)

             (set-face-attribute 'magit-item-highlight nil
                                 :background "black")

             (global-set-key (kbd "\C-c m")      'magit-status)
             (global-set-key (kbd "\C-c RET")    'magit-status))
         (message "WARNING: magit not found"))))
#+END_SRC

* Ido selection

As software evolution goes, certain designs tend to become some kind of a
standard. They turn out to be such a huge success, that, basically, everybody
employ it. And when sometimes you see a different solution - you feel awkward,
at least.

Like, for example, it's not that easy to find a modern widespread editor without
"tabs", i.e. some kind of bookmarks at the top for different files. Also, every
desktop browser, that I know of, uses this "tabs" design to allow switching
among different pages.

Emacs windows and buffers system serves the same purpose as this "tabs" design.
And the more I used it, the more I realized, that it was a way better design for
what it does.

But I was feeling awkward using it. And =ido= made this awkwardness feel really
pleasant. Now I'll give it away only when you pry it from my cold, dead hands.

For me, it works great as-is with flexible matching enabled. Personally, I don't
see the point of =ido-flx= and relatives. I really don't get what problems those
packages are trying to solve. Also, I like the vanilla "horizontal" ido more,
not the "vertical" modification.

So, the only interesting thing I can tell about my =ido= setup is that buffer
switching is bound to =C-TAB=. The idea came to me from desktop browsers. One
thing about it - it's a shorter and easier alternative to =C-x b=. And the other
thing, which was a nice surprise to me, but may be a controversy to others - it
is not representable by an ASCII sequence, so it won't work in a terminal.

You may ask why is this a good thing? Because if I use terminal, I use it inside
Emacs via =ansi-term= most of the time. If the sequence would've been ASCII one,
then it would be sent to terminal and Emacs command wouldn't be executed.

=C-x b= (which is an ASCII sequence) also works in =term=, because =C-x= is
handled specially in =term-mode=. But it's not as convenient as =C-TAB=.

#+BEGIN_SRC emacs-lisp
  (when (require 'ido nil t)
    (ido-mode 1)
    (setq-default ido-enable-flex-matching t)
    (global-set-key [C-tab] 'ido-switch-buffer))
#+END_SRC

There are some modes, like, =ido-ubiquitous=, which enable =ido= in almost every
"completing situation". But I find that =ido= doesn't really shine in a lot of
other situations, so I prefer using it only for buffers, files and =M-x=
completions. For the latter I use =smex=, because it does it right.

#+BEGIN_SRC emacs-lisp
  (eval-after-load "smex-autoloads"
    '(progn
       (if (require 'smex nil t)
           (progn
             (smex-initialize)
             (global-set-key (kbd "M-x") 'smex))
         (message "WARNING: smex not found"))))
#+END_SRC

Not a lot of people know this, but the trend to add "i"s to words to make them
look iCool was popular in Emacs long before Apple had came about. Behold another
precedent: Ibuffer. Frankly, I don't use it much, but it's kind of nice to have
when you need it.

#+BEGIN_SRC emacs-lisp
  (require 'ibuffer nil t)
  ;; ibuffer groups
  (setq-default ibuffer-saved-filter-groups
                (quote (("default"
                         ("org"  (mode . org-mode))
                         ("dired" (mode . dired-mode))
                         ("D" (mode . d-mode))
                         ("C/C++" (or
                                   (mode . cc-mode)
                                   (mode . c-mode)
                                   (mode . c++-mode)))
                         ("magit" (name . "^\\*magit"))
                         ("Markdown" (mode . markdown-mode))
                         ("emacs" (name . "^\\*Messages\\*$"))
                         ("shell commands" (name . "^\\*.*Shell Command\\*"))))))
  (add-hook 'ibuffer-mode-hook
            (lambda ()
              (ibuffer-switch-to-saved-filter-groups "default")))

  (global-set-key (kbd "\C-x \C-b") 'ibuffer)
#+END_SRC

* Using external websites

Googling today became so common, that the corresponding word became an official
English word according to the Oxford dictionary. Now, we take it to another
level, and add an Emacs keybinding to google even faster!

If the region is selected, when you press =C-c g=, it will google it. Otherwise,
it will query for the text to be googled.

Similarly, you can use =C-c l= to lingvo something (translate from Russian to
English or vice versa) and =C-c u= to Urban Dictionary something.

#+BEGIN_SRC emacs-lisp
  (defmacro url-do-it (backend-name query-beginning docstring)
    `(defun ,(intern (format "%s-it" (mapconcat 'identity (split-string (downcase backend-name)) "-"))) ()
       ,(format "%s the selected region if any, display a query prompt otherwise" docstring)
       (interactive)
       (browse-url
        (concat
         ,query-beginning
         (url-hexify-string (if mark-active
                                (buffer-substring (region-beginning) (region-end))
                              (read-string (concat ,backend-name ": "))))))))

  (global-set-key (kbd "\C-cg") (url-do-it "Google" "http://www.google.com/search?ie=utf-8&oe=utf-8&q=" "Google"))
  (global-set-key (kbd "\C-cl") (url-do-it "Lingvo" "http://lingvopro.abbyyonline.com/en/Translate/en-ru/" "Translate (using Lingvo)"))
  (global-set-key (kbd "\C-cu") (url-do-it "Urban Dictionary" "http://www.urbandictionary.com/define.php?term=" "Find a definition in Urban Dictionary for"))
#+END_SRC

* Window management
** Selecting windows

For some reason, Emacs has at least 4 different bindings to provide a prefix
argument to a function:
1. =C-u <argument> <command>=
2. =C-<argument> <command>=
3. =M-<argument> <command>=
4. =C-M-<argument> <command>=

I can more or less understand why you need an alternative to the first option.
But why do you need all 2-3-4, which are about the same? Especially, given those
bindings are quite good bindings - brief and convenient. Something you have a
shortage of in Emacs.

So, it's obvious, we should bind 2 of those to something else. We only have to
find an appropriate functionality. And the =window-numbering= mode author has a
brilliant idea for third option rebinding.

My only way of windows switching was to use the =C-x o= binding, which works
fine, when you have only 2 windows. Admittedly, it is the case for me 95% of the
time. I was struggling during the last 5% of the time, but thought, that it's
something I can live with.

And then I came across the =window-numbering= mode which made a lot of sense to
me. Using =M-<number>= to switch between windows is a perfect crime.

At first, I didn't use it that much, because of the habit. But every time I was
in the "5% zone" I immediately remembered about this mode and used it happily.
Now, having this mode around for quite some time already, I find myself using it
more and more often.

In fact, this mode makes so much sense to me, that when I advertise Emacs to
others, I present =window-numbering= way of windows switching as the default
one. And I haven't yet seen anybody to have issues with that.

The last thing I should say about is that =M-0= takes you to minibuffer by
default, which is also very handy.

A very nice mode.

#+BEGIN_SRC emacs-lisp
  (eval-after-load "window-numbering-autoloads"
    '(progn
       (if (require 'window-numbering nil t)
           (progn
             (window-numbering-mode 1)
             (add-hook 'minibuffer-setup-hook
                       'window-numbering-update))
         (message "WARNING: window-numbering-mode not found"))))
#+END_SRC

** Messing around

As I've said, I use 2 buffers almost all the time. And I have 2 handy functions
for that case.

1. Toggle window split

   #+BEGIN_SRC emacs-lisp
     (define-key global-map (kbd "\C-c f")
       (defun toggle-window-split ()
         "Switches from a horizontal split to a vertical split and visa versa."
         (interactive)
         (if (= (count-windows) 2)
             (let* ((this-win-buffer (window-buffer))
                    (next-win-buffer (window-buffer (next-window)))
                    (this-win-edges (window-edges (selected-window)))
                    (next-win-edges (window-edges (next-window)))
                    (this-win-2nd (not (and (<= (car this-win-edges)
                                                (car next-win-edges))
                                            (<= (cadr this-win-edges)
                                                (cadr next-win-edges)))))
                    (splitter
                     (if (= (car this-win-edges)
                            (car (window-edges (next-window))))
                         'split-window-horizontally
                       'split-window-vertically)))
               (delete-other-windows)
               (let ((first-win (selected-window)))
                 (funcall splitter)
                 (if this-win-2nd (other-window 1))
                 (set-window-buffer (selected-window) this-win-buffer)
                 (set-window-buffer (next-window) next-win-buffer)
                 (select-window first-win)
                 (if this-win-2nd (other-window 1)))))))

   #+END_SRC

2. Swap buffers in windows

   #+BEGIN_SRC emacs-lisp
     (define-key global-map (kbd "\C-c s")
       (defun swap-buffers-in-windows ()
         "Put the buffer from the selected window in next window"
         (interactive)
         (let* ((this (selected-window))
                (other (next-window))
                (this-buffer (window-buffer this))
                (other-buffer (window-buffer other)))
           (set-window-buffer other this-buffer)
           (set-window-buffer this other-buffer)
           ;; comment next call to stay in current window
           (select-window other))))
   #+END_SRC

   Note, this function can be used not only for swapping 2 buffers, but also for
   "dragging" the current buffer to some other window, when there's more than 2
   of those. Similar to how you can use consecutive invocations of
   =transpose-words= to "drag" the word forward.
* Embedded lisp evaluation

One particularly unusual thing about Emacs for somebody coming from a "common"
development environment is that you always have an executable language right
under your cursor.

It is difficult to acknowledge this properly until you get used to the elisp
language. But once you're at the level, where you can write a small elisp
function, you will find yourself using it more and more often in a variety of
cases.

Emacs has a built-in binding =C-x C-e=, which evaluates the elisp form on the
left from the cursor (i.e. previous form). The default functionality prints the
result to the echo area, leaving the form as is. But quite often it is pretty
useful to write some small form in non-elisp buffer, evaluate it and paste the
result into the buffer instead of the form.

E.g. you're writing a technical article, and at some point you need a value for
a quarter of Pi. Probably, a lot of people know several digits of the Pi value.
That's how many I know by heart - =3.14159265358=. Probably, a lot of people
also know some digits of half-Pi and twice-Pi. For me, it's just 3 digits in
both cases - =1.57= and =6.28=. But do a lot of people remember what is the
quarter of Pi? I can't name a single digit (except for the leading zero) without
performing an evaluation.

But why bother at all, when you can write =(/ 3.1415 4)=, hit =C-x C-e= and it
will be replaced with =0.785375=. Of course, you can also write =(/ float-pi
4)=. You can also apply any other functions you might need.

And, obviously, you can use not only mathematical functions, but any of the
variety of different elisp functions. At the time of writing I have as much as
=18272= functions available. Not all of them are particularly useful for that
kind of usage, but still it gives you the perspective.

The examples from my daily job include:

1. Evaluate simple mathematical forms: =(+ 1 2 -9 16.16)=, =(sin (/ float-pi 2))=
2. Get current date: =(format-time-string "%b %d, %Y")=
3. Add leading zeros: =(format "%04d" 4)=

If you want the form to stay in place and simply print the result to the echo
area, then you should select it with a region before pressing =C-x C-e=.

You can also evaluate the region in debugging mode - use the universal argument
for that - =C-u C-x C-e=. If there's a function definition inside the selected
region, then successive calls to that function will also happen in debug mode.
To cancel this behavior, simply evaluate the respective functions without a
universal argument. This is similar to =C-M-x= / =C-u C-M-x= behavior in
=emacs-lisp-mode=.

#+BEGIN_SRC emacs-lisp
  (defun eval-and-replace ()
    "Replace the preceding sexp with its value."
    (interactive)
    (backward-kill-sexp)
    (condition-case nil
        (prin1 (eval (read (current-kill 0)))
               (current-buffer))
      (error (message "Invalid expression")
             (insert (current-kill 0)))))

  (defun eval-dispatch (arg)
    "Evaluate previous sexp or region"
    (interactive "P")
    (if (region-active-p)
        (let ((edebug-all-forms arg))
          (eval-region (region-beginning) (region-end) t))
      (eval-and-replace)))

  (global-set-key (kbd "\C-x\C-e")    'eval-dispatch)
#+END_SRC

* Field applications

There was a period of my work, when I was implementing a computer vision
algorithm. To test and improve it, I had to generate a 3D scene and experiment
with different camera positions and fields of view. For example, I had to figure
out something like: "Do we get a good quality if we use four 55 degree cameras
and place them like that?"

After I generated the images of a 3D scene, I had to process those. And as you
may know, for a computer vision application, the most common representation of
the camera intrinsic parameters is /camera matrix/. It's a 3x3 matrix of the
following form:

| fx |  0 | px |
|  0 | fy | py |
|  0 |  0 | 1  |

where fx and fy are the /focal lengths/ in x and y dimensions. This matrix is
used to convert image coordinates to camera world coordinates and visa-versa.

Focal length can be unambiguously evaluated given the field-of-view of the
camera: focal = tan^{-1}(fov / 2). And, of course, you can make a conversion in
the opposite direction: fov = 2 atan(focal^{-1}).

This is not quantum physics, by all means. But I used this formulas rare enough,
that I had to look them up every time I needed those, and often enough to be
annoyed by this. Add to the annoyance, that after I found the formula, I had to
perform something like 5 operations in =calc= to evaluate it.

And at some point it struck me, that I'm using Emacs. A text editor with a
primary goal to allow me to build the best working environment for myself. Just
for me, you know? It's not that some guy or a big company is sitting somewhere
trying to think of everything I might need. It cannot ever work like that.
Because how should they know that I need those formulas? If I was working in
some other place - I wouldn't need those formulas. Or, more likely, I would need
some other ones.

And maybe not even formulas, but something else. Like, just now, while I was
writing this, a colleague of mine asked me "How you can take 2 videos and stack
them vertically?". I wrote =ffmpeg-top-bottom= and hit =M-/=, it expanded to a
command found in my =.abbrev_defs= file and I sent it to her.

She remembered, that I had already sent her this command previously, but she
couldn't find it anywhere. I smiled about it and told her that she can ask me as
many times as needed, because I always have it at hand.

Anyway, long story short. That time I was thinking of focal lengths was the time
when I really appreciated the "extensibility" part of Emacs. I wasn't too
thrilled about it when I just started using it. I was always, like, "Somebody
else must have already built a perfect environment. I should simply find it and
use it". Needless to say, I'm still looking for this "perfect environment".

But at that day, I put the following functions to my init file and moved on
enlightened. From that moment, when I need a conversion I just write something
like =(fov2focal (deg2rad 55))= and hit =C-x C-e=.

Yeah. At that day, I became a bit closer to a perfect working environment.

#+BEGIN_SRC emacs-lisp
  (defun deg2rad (x)
    "Converts degrees to radians"
    (/ (* x float-pi) 180.0))

  (defun rad2deg (x)
    "Converts radians to degrees"
    (/ (* x 180.0) float-pi))

  (defun fov2focal (fov)
    "Evaluates dimensionless focal length given fov in radians"
    (/ 1.0 (tan (/ fov 2.0))))

  (defun focal2fov (focal)
    "Evaluates fov in radians given dimensionless focal length"
    (* 2.0 (atan (/ 1.0 focal))))
#+END_SRC

* Browse kill ring

One of the greatest Emacs features is the kill ring.

Everything you kill (i.e. cut) is stored in a ring (i.e. circular buffer). You
have access to 60 (the number can be increased) most recently killed regions -
not only 1, like you do in a lot of other editors.

The only drawback is that sometimes you want to search for something in the kill
ring and there's no good built-in representation for it. You can press =M-y=
until you find what you want, but it's not very convenient. Inspecting the value
of the =kill-ring= variable doesn't help much also.

=browse-kill-ring= mode solves this problem by providing kill ring contents in a
separate buffer. I bind it to =C-x C-y=, so it looks like something built-in.
When you find what you need, simply press =C-m= (=Enter=) and that's it.

#+BEGIN_SRC emacs-lisp
  (eval-after-load "browse-kill-ring-autoloads"
    '(progn
       (when (require 'browse-kill-ring nil t)
         (global-set-key (kbd "C-x C-y") 'browse-kill-ring)
         (define-key browse-kill-ring-mode-map (kbd "C-c C-k") 'browse-kill-ring-quit)
         (define-key browse-kill-ring-mode-map (kbd "C-x C-k") 'browse-kill-ring-quit)
         (define-key browse-kill-ring-mode-map (kbd "C-x k") 'browse-kill-ring-quit)
         (setq browse-kill-ring-quit-action 'save-and-restore))))
#+END_SRC

* Navigate to previous position

Oddly enough, Emacs doesn't really have a solid functionality to jump to a
previous editing position. The closest solution is to use =C-u C-SPC= to jump to
a previous mark in the current buffer and =C-x C-SPC= to jump to a previous mark
across buffers. It's not great, but a small fish is better than an empty dish.

The only thing is that quite often you have a lot of duplicate marks in the ring
and it's tedious to pop those by one. So, I bind a simple wrapper to =C-M-\= -
it works as =C-u C-SPC=, but ignores duplicate marks. And it works as =C-x
C-SPC= when used with a universal argument =C-u C-M-\=.

#+BEGIN_SRC emacs-lisp
  (define-key global-map (kbd "C-M-\\")
    (defun pop-mark-jump (arg)
      "Jump to the mark "
      (interactive "P")
      (if arg
          (pop-global-mark)
        (delete-dups mark-ring)
        (set-mark-command '(4)))))
#+END_SRC
* Get full path

Quite often you need a full path to some file, and there's a plenty of ways to
get it.

- First, obviously, you can press =C-x C-f= and find your file there.
- Then, in Dired you can press =w= to get only the name or =C-0 w= to get the
  full path.
- Also, you can use the =C-c w= binding to get full path to the current file
  #+BEGIN_SRC emacs-lisp
    (define-key global-map (kbd "\C-c w")
      (defun show-file-name ()
        "Show the full path file name in the minibuffer and add it to kill ring"
        (interactive)
        (message (buffer-file-name))
        (kill-new (buffer-file-name))))
  #+END_SRC
- And the last, but not least, if you have a short path around point, you can
  use =C-x /= to expand it to a full path. I use this quite often in conjunction
  with buffer-local =compile-command= setting. If I have a script that I want to
  run using =compile=, I do the following:
  - open the script (say, "build-and-run.bash") and press =C-c C-c=
  - then write "cd ."
  - press =C-x /= to expand the dot (say, "cd /home/sergei/project/build")
  - append script execution - "cd /home/sergei/project/build && bash
    build-and-run.bash"

  Now I can switch to another buffer, press =M-p= after =C-c C-c= and use the
  same compile command, because the path is absolute.

  #+BEGIN_SRC emacs-lisp
    (define-key global-map (kbd "C-x /")
      (defun replace-path-with-truename ()
        "Replaces the region or the path around point with its true name.

    To get the true name it follows the symbolic links and converts
    relative paths to absolute."
        (interactive)
        (let (bds p1 p2 inputStr resultStr)
          ;; get current selection or filename
          (if (region-active-p)
              (setq bds (cons (region-beginning) (region-end) ))
            (setq bds (bounds-of-thing-at-point 'filename)))
          (setq p1 (car bds))
          (setq p2 (cdr bds))

          (let ((fn (buffer-substring-no-properties p1 p2)))
            (if (file-exists-p fn)
                (progn
                  (delete-region p1 p2 )
                  (insert (file-truename fn)))
              (message "Path \"%s\" doesn't exist" fn))))))
  #+END_SRC
* Multiple cursors

"Multiple cursors" is a kind of feature that doesn't sound like a very good idea
the first time you hear about it. It seems too tricky and complex to be useful.
And I was also sceptic, when I first saw it in Sublime Text 2 editor: "What good
can you expect from the guys that invented minimap?".

But one day I watched a video by Magnar Sveen, where he showed-off his
implementation of multiple cursors in Emacs. I got the impression that he,
himself, didn't really know how to use them properly, but somehow it had a ring
to him.

The idea from the video that also rang to me was selecting a word and adding
auxiliary cursors on other occurrences of the same word. I didn't know how
useful it was when I saw it, but I decided to give it a try.

At first, I wasn't really using it much, because I didn't have the habit. And,
to be honest, the concept is indeed a bit alien if you've never used it. But
eventually, I worked out a style of using multiple cursors, which goes for me.
It turned out to be so convenient, that now I can't imagine myself giving it up.

The 2 most commonly used bindings are =C->= and =C-<=:

- If the region is active (e.g. a word is selected), then =C->= searches for the
  next occurrence of this region and creates an additional cursor when it finds
  one. Similarly, =C-<= searches for a previous occurrence.
- If no region is selected, then the cursor is added on the next (previous) line.
- To "skip" an occurrence, provide a zero prefix argument, e.g. =C-0 C->=.
- To delete the last added cursor, provide a negative argument, e.g. =C-- C->=.
- To remove all the "fake" cursors, use =C-g=.

The next important binding is =M-@=:

- If no region is selected, then it adds a cursor in the exact same position of
  the current cursor.
- If the selected region is entirely on a single line, than it searches the
  whole buffer for the occurrences of this region and adds cursors on each one
  of them.
- If the selected region spans multiple lines, then it adds a cursor on each
  line.

Now we're getting on speed. Once you already have multiple cursors, =M-#= adds
successive numbers in the place of each cursor. E.g. if you have 3 cursors, then
pressing =M-#= will print 0 in the position of the first cursor, 1 - in the
position of the second cursor and 2 - in the position of the third cursor. If
you provide a prefix argument, say, =C-3 M-#=, the printed numbers will start
with it - 3, 4, 5.

Consider, for example, that you want to write the following code:

#+BEGIN_EXAMPLE
  array[0] = 0;
  array[1] = 2;
  array[2] = 4;
  array[3] = 6;
  array[4] = 8;
  array[5] = 10;
#+END_EXAMPLE

What you do is:

- place the cursor in the beginning of the line and add 6 cursors =C-6 C->=
- type "array["
- hit =M-#= to add the digits
- type the closing "]" (if it's not already there)
- then type " = ", "(* 2 ", =M-#= and ")"

What we have at this point is:

#+BEGIN_EXAMPLE
  array[0] = (* 2 0)
  array[1] = (* 2 1)
  array[2] = (* 2 2)
  array[3] = (* 2 3)
  array[4] = (* 2 4)
  array[5] = (* 2 5)
#+END_EXAMPLE

Assuming that the cursors are at the end of each line, we press =C-x C-e= (which
is bound to =eval-and-replace=), add semicolons and get what we want.

Neat, huh? But wait, there's more. Hang on to yer helmet! Do you need to
initialize, say, some kind of "point" structure as well?

#+BEGIN_EXAMPLE
  point.x = vec[0];
  point.y = vec[1];
  point.z = vec[2];
#+END_EXAMPLE

Here's a tip:

#+BEGIN_EXAMPLE
  point.(char-to-string (+ ?x 0))
  point.(char-to-string (+ ?x 1))
  point.(char-to-string (+ ?x 2))
#+END_EXAMPLE

Confused? Don't be - if you evaluate the lisp forms you will get "x", "y" and
"z" as the results. Only your imagination is the limit when using the =M-#=
function.

BTW, I have this scary form =(char-to-string (+ ?x ))= in the abbrev table, so
all I have to do is type "char" and hit =M-/=.

Last, but not least - M-', which is an experimental function written by me. It
aligns all of your cursors by adding the necessary number of spaces in the
positions of every cursor.

For example, if you have a code, like

#+BEGIN_EXAMPLE
  object.width = 30;
  object.height = 150;
  object.temperature = 300;
#+END_EXAMPLE

You can select the word =object=, hit =M-@=, =M-f=, =C-g= and M-' to make it
look like this:

#+BEGIN_EXAMPLE
  object.width       = 30;
  object.height      = 150;
  object.temperature = 300;
#+END_EXAMPLE

You can do the same thing with the help of =align-regexp=, but if you created
the cursors anyway, then M-' is a handy tool.

If you feel overwhelmed by all the vast functionality this mode provides - don't
let it stop you from trying it out. Start with simple things, like =C->= and
=C-<=. Soon you will find yourself pretty comfortable with it and then you will
start using other functions - little by little.

#+BEGIN_SRC emacs-lisp
  (eval-after-load "multiple-cursors-autoloads"
    '(progn
       (when (require 'multiple-cursors nil t)
         (defun mc/mark-all-dispatch ()
           "- add a fake cursor at current position

  - call mc/edit-lines if multiple lines are marked

  - call mc/mark-all-like-this if marked region is on a single line"
           (interactive)
           (cond
            ((not (region-active-p))
             (mc/create-fake-cursor-at-point)
             (mc/maybe-multiple-cursors-mode))
            ((> (- (line-number-at-pos (region-end))
                   (line-number-at-pos (region-beginning))) 0)
             (mc/edit-lines))
            (t
             (mc/mark-all-like-this))))

         (defun mc/align ()
           "Aligns all the cursor vertically."
           (interactive)
           (let ((max-column 0)
                 (cursors-column '()))
             (mc/for-each-cursor-ordered
              (mc/save-excursion
               (goto-char (overlay-start cursor))
               (let ((cur (current-column)))
                 (setq cursors-column (append cursors-column (list cur)))
                 (setq max-column (if (< max-column cur) cur max-column)))))

             (defun mc--align-insert-times ()
               (interactive)
               (dotimes (_ times)
                 (insert " ")))

             (mc/for-each-cursor-ordered
              (let ((times (- max-column (car cursors-column))))
                (mc/execute-command-for-fake-cursor 'mc--align-insert-times cursor))
              (setq cursors-column (cdr cursors-column)))))

         (setq mc/list-file "~/.mc-lists.el")
         (load mc/list-file t) ;; load, but no errors if it does not exist yet please

         (global-set-key (kbd "C->")  'mc/mark-next-like-this)
         (global-set-key (kbd "C-<")  'mc/mark-previous-like-this)

         (global-set-key (kbd "M-@") 'mc/mark-all-dispatch)
         (global-set-key (kbd "M-#") 'mc/insert-numbers)
         (global-set-key (kbd "M-'") 'mc/align))))
#+END_SRC
* Sudo edit

Sometimes you need root rights to edit a file, e.g. some config in the "/etc"
directory. Most of the time, you will open it in Emacs as usual to find out that
you cannot edit it and you actually need the root rights.

In that case you can simply press =C-x != to re-open it using a "sudo" protocol.
It works for remote files opened via TRAMP ssh protocol as well.

#+BEGIN_SRC emacs-lisp
  (defun add-sudo-to-filename (filename)
    "Adds sudo proxy to filename for use with TRAMP.

  Works for both local and remote hosts (>=23.4). The syntax used
  for remote hosts follows the pattern
  '/ssh:you@remotehost|sudo:remotehost:/path/to/file'. Some people
  say, that you may need to call smth like
  `(set-default 'tramp-default-proxies-alist (quote ((\".*\"
  \"\\`root\\'\" \"/ssh:%u@%h:\"))))', but it works for me just fine
  without it. "
    (with-temp-buffer
      (insert filename)
      (goto-char (point-max))
      (if (re-search-backward "@\\(.*\\):" nil t)
          (let ((remote-name (buffer-substring (match-beginning 1) (match-end 1))))
            (goto-char (match-end 1))
            (insert (concat "|sudo:" remote-name))
            (goto-char (point-min))
            (forward-char)
            (when (looking-at "scp")
              (delete-char 3)
              (when (looking-at "c")
                (delete-char 1))
              (insert "ssh"))
            (buffer-string))
        (concat "/sudo::" filename))))

  (define-key global-map (kbd "\C-x!")
    (defun sudo-edit-current-file (&optional arg)
      "Edit currently visited file as root.

  With a prefix ARG prompt for a file to visit.
  Will also prompt for a file to visit if current
  buffer is not visiting a file."
      (interactive "P")
      (if (or arg (not buffer-file-name))
          (find-file (concat "/sudo:root@localhost:"
                             (ido-read-file-name "Find file(as root): ")))
        (let ((position (point)))
          (find-alternate-file (add-sudo-to-filename buffer-file-name))
          (goto-char position)))))
#+END_SRC
* Ediff

In the pre-magit era I had to provide the ediff interface as an external tool to
the version control systems. It wasn't the most clean experience, but it worked.

Fortunately, now we don't have to resort to hacks like this - we can simply
press =e= in magit buffer - both to see the diff and resolve conflicts.

The only thing is that the default ediff user experience comes from stone age,
so I had to tweak it a bit.

First, a couple of functions to save and restore window configuration after
ediff session.

#+BEGIN_SRC emacs-lisp
  (require 'ediff)

  (defun ediff-save-window-configuration ()
    (window-configuration-to-register ?E))
  (defun ediff-restore-window-configuration ()
    (jump-to-register ?E))

  (setq-default ediff-before-setup-hook (quote (ediff-save-window-configuration)))
  (setq-default ediff-quit-hook (quote (ediff-cleanup-mess ediff-restore-window-configuration exit-recursive-edit)))
  (setq-default ediff-suspend-hook (quote (ediff-default-suspend-function ediff-restore-window-configuration)))
#+END_SRC

Then, I don't want ediff to create other frames. Everything should stay in the
same frame I'm working in. And the splitting should be horizontal (i.e.
side-by-side).

#+BEGIN_SRC emacs-lisp
  (setq-default ediff-window-setup-function (quote ediff-setup-windows-plain))
  (setq-default ediff-split-window-function (quote split-window-horizontally))
#+END_SRC

Also, I prefer that the difference regions are always highlighted, not just when
those are "active". And, of course, it's more convenient when the diff is
refined by chars, not words.

#+BEGIN_SRC emacs-lisp
  (setq-default ediff-highlight-all-diffs t)
  (setq-default ediff-forward-word-function 'forward-char)
#+END_SRC

The last thing is that the default colors are not very pretty, so I replaced
them with something that looks like the kdiff3 default theme, because it was my
previous favorite diff viewing tool.

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'ediff-current-diff-A nil :background "white" :foreground "black")
  (set-face-attribute 'ediff-current-diff-Ancestor nil :background "white" :foreground "black")
  (set-face-attribute 'ediff-current-diff-B nil :background "white" :foreground "black")
  (set-face-attribute 'ediff-current-diff-C nil :background "white" :foreground "black")
  (set-face-attribute 'ediff-even-diff-A nil :background "antique white" :foreground "Black")
  (set-face-attribute 'ediff-even-diff-Ancestor nil :background "antique white" :foreground "black")
  (set-face-attribute 'ediff-even-diff-B nil :background "antique white" :foreground "black")
  (set-face-attribute 'ediff-even-diff-C nil :background "antique white" :foreground "Black")
  (set-face-attribute 'ediff-fine-diff-A nil :background "gainsboro" :foreground "blue")
  (set-face-attribute 'ediff-fine-diff-Ancestor nil :background "gainsboro" :foreground "red")
  (set-face-attribute 'ediff-fine-diff-B nil :background "gainsboro" :foreground "forest green")
  (set-face-attribute 'ediff-fine-diff-C nil :background "gainsboro" :foreground "purple")
  (set-face-attribute 'ediff-odd-diff-A nil :background "antique white" :foreground "black")
  (set-face-attribute 'ediff-odd-diff-Ancestor nil :background "antique white" :foreground "black")
  (set-face-attribute 'ediff-odd-diff-B nil :background "antique white" :foreground "Black")
  (set-face-attribute 'ediff-odd-diff-C nil :background "antique white" :foreground "black")

  (set-face-attribute 'diff-added nil :foreground "green")
  (set-face-attribute 'diff-file-header nil :background "black" :weight 'bold)
  (set-face-attribute 'diff-header nil :background "black")
  (set-face-attribute 'diff-refine-change nil :background "dark slate gray")
  (set-face-attribute 'diff-removed nil :foreground "tomato")
#+END_SRC
* Term

I don't need an actual terminal emulator often, because I can issue shell
commands with =M-&= and =C-c C-c=. But sometimes I do need a terminal. And when
I need one, I need a "real" PTY emulator, not =shell= or =eshell=.

The built-in =M-x ansi-term= is a more or less decent emulator in that regard.
It has rough edges and maybe it's not the best emulator ever, but, hey, it's
good enough to run Vim and other obscure terminal software. You can definitely
live with it.

First, let's bind =C-x C-l= to trigger =line-mode=, where you can navigate the
buffer without sending commands to the terminal, and bind =C-x C-k= to trigger
=char-mode=, where all the input commands are sent to terminal.

#+BEGIN_SRC emacs-lisp
  (require 'term)

  (define-key term-mode-map "\C-x\C-j"   'dired-jump-universal-other)
  (define-key term-raw-escape-map "\C-j" 'dired-jump-universal-other)
  (define-key term-raw-escape-map "\C-l" 'term-line-mode)
  (define-key term-mode-map "\C-x\C-k"   'term-char-mode)
#+END_SRC

For persistence, let's go to the end of the buffer and trigger the =char-mode=
when switching to the terminal buffer.

#+BEGIN_SRC emacs-lisp
  (defadvice ido-switch-buffer (after maintain-ansi-term activate)
    "Go to prompt when switched to ansi-term"
    (when (member major-mode '(term-mode))
      (term-line-mode)
      (end-of-buffer)
      (end-of-line)
      (term-char-mode)))
#+END_SRC

The default term colors are unreadable for some reason, so I spent quite some
time to find decent alternatives.

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'term-color-black nil   :background "#1d1f21" :foreground "#1d1f21")
  (set-face-attribute 'term-color-blue nil    :background "#81a2be" :foreground "#81a2be")
  (set-face-attribute 'term-color-green nil   :background "firebrick" :foreground "firebrick")
  (set-face-attribute 'term-color-magenta nil :background "#b294bb" :foreground "#b294bb")
  (set-face-attribute 'term-color-red nil     :background "#cc6666" :foreground "#cc6666")
  (set-face-attribute 'term-color-white nil   :background "#c5c8c6" :foreground "#c5c8c6")
  (set-face-attribute 'term-color-yellow nil  :background "#f0c674" :foreground "#f0c674")
#+END_SRC

All of the above were some minor tweaks to the existing =ansi-term=
functionality. What comes next could also be considered a minor tweak if you
think of the lines-of-code count. But it is a really powerful feature I use with
great pleasure.

A simple question - how do you work on a remote workstation via ssh?

The most popular answer I hear is to open a terminal and work from there.
Probably, this fact is one of the good reasons for people to use Vim. It's an
overkill to install Emacs and your configuration on every remote you work with.
Especially, if you want to do something simple. On the contrary, Vim is
pre-installed on pretty much any platform and since conscientious Vim users
don't need a lot of configuration, it's a workable solution for them.

Obviously, Emacs has it's own solution, but, surprisingly, it doesn't lie on a
surface - you have to figure it out yourself. Let me try to explain to you how
conscientious Emacs users work on remote machines.

First thing, you may already know, is that you can provide a configuration file
to =ssh= - normally, it's =~/.ssh/config=. In this file you can have records,
like:

#+BEGIN_EXAMPLE
  Host server1
       User snosov1
       HostName 192.168.0.14

  Host distant-ws
       User sergei
       Port 324
       HostName 83.123.44.2
#+END_EXAMPLE

With those records you can use a shorthand command, like =ssh distant-ws= to
connect to the server without specifying username, host and port. Pretty neat.

But there's more. When you start Emacs, my little function
=term-parse-ssh-config= will parse this config file and save a list of then
hosts. Then, you can issue =M-x remote-term= command and it will ask you for a
hostname (with enabled completion) and open an ssh session in the =ansi-term=
window. Not bad, huh?

#+BEGIN_SRC emacs-lisp
  (defcustom term-remote-hosts '()
    "List of remote hosts"
    :group 'term)

  (defcustom ssh-config-filename "~/.ssh/config"
    "ssh config filename"
    :group 'term)

  (funcall
   (defun term-parse-ssh-config ()
     "Parse `ssh-config-filename' to provide `remote-term'
    completion capabilities."
     (interactive)
     (setq term-remote-hosts '())
     (if (file-exists-p ssh-config-filename)
         (with-temp-buffer
           (find-file ssh-config-filename)
           (goto-char (point-min))
           (while (re-search-forward "Host\\s-+\\([^\s]+\\)$" nil t)
             (let ((host (match-string-no-properties 1)))
               (add-to-list 'term-remote-hosts `(,host "ssh" ,host))))
           (kill-buffer)))))

  (defun remote-term-do (new-buffer-name cmd &rest switches)
    "Fires a remote terminal"
    (let* ((term-ansi-buffer-name (concat "*" new-buffer-name "*"))
           (term-ansi-buffer-name (generate-new-buffer-name term-ansi-buffer-name))
           (term-ansi-buffer-name (apply 'term-ansi-make-term term-ansi-buffer-name cmd nil switches)))
      (set-buffer term-ansi-buffer-name)
      (term-mode)
      (term-char-mode)
      (term-set-escape-char ?\C-x)
      (switch-to-buffer term-ansi-buffer-name)))

  (defun remote-term (hostname)
    (interactive
     (list (completing-read "Remote host: " term-remote-hosts)))
    (dolist (known-host term-remote-hosts)
      (when (equal (car known-host) hostname)
        (apply 'remote-term-do known-host))))
#+END_SRC

But wait, there's even more.

- =M-x remote-authorize= will add your public key to the authorized keys list on
  the remote and it won't ask you for authentication anymore. In order to work,
  this function assumes that you already have generated a key pair via
  #+BEGIN_EXAMPLE
    ssh-keygen -t rsa -C "your_email@example.com"
  #+END_EXAMPLE
- =M-x remote-enable-dired= will modify the ".profile" file on the remote, so
  that when you'll press =C-x C-j= for a =dired-jump= in the remote terminal
  (opened with =M-x remote-term=), it will open dired for the remote directory.

Those functions enable you to work with the remote exactly as you would work
with a local workstation. No need to resort to terminal, no need to install
Emacs and your configuration on the remote. You will simply use your local Emacs
instance.

Needless to say, stuff, like, copying files from remote dired buffer to local
dired buffer, will work transparently - no need for =scp= or anything.

And all of this is enabled with just 3 simple steps:

- add a record to =~/.ssh/config= and re-open Emacs or call =M-x
  term-parse-ssh-config=
- call =M-x remote-authorize=
- call =M-x remote-enable-dired=

It is a tremendously convenient and useful functionality. The only caveat is
that you should name the hosts in your ssh config file with the same names that
are specified in the =/etc/hostname= on the remotes.

#+BEGIN_SRC emacs-lisp
  (defcustom ssh-public-key-filename "~/.ssh/id_rsa.pub"
    "ssh public key filename"
    :group 'term)

  (defun remote-authorize (hostname)
    (interactive
     (list (completing-read "Remote host: " term-remote-hosts)))
    (async-shell-command
     (concat "cat " ssh-public-key-filename
             " | ssh " hostname
             " 'mkdir -p .ssh && cat - >>.ssh/authorized_keys'")))

  (defun remote-enable-dired (hostname)
    (interactive
     (list (completing-read "Remote host: " term-remote-hosts)))
    (let ((filename (concat temporary-file-directory ".profile")))
      (with-temp-file filename
        (insert "######################################################################\n# Put this in your remote system's .profile for remote bash to track\n# your current dir\nset_eterm_dir () {\n    echo -e \"\\033AnSiTu\" \"$LOGNAME\" # $LOGNAME is more portable than using whoami.\n    echo -e \"\\033AnSiTc\" \"$(pwd)\"\n    if [ $(uname) = \"SunOS\" ]; then\n\t    # The -f option does something else on SunOS and is not needed anyway.\n       \thostname_options=\"\";\n    else\n        hostname_options=\"-f\";\n    fi\n    echo -e \"\\033AnSiTh\" \"$(hostname $hostname_options)\" # Using the -f option can cause problems on some OSes.\n    history -a # Write history to disk.\n}\n\n# Track directory, username, and cwd for remote logons.\nif [ \"$TERM\" = \"eterm-color\" ]; then\n    PROMPT_COMMAND=set_eterm_dir\nfi\n######################################################################\n"))
      (async-shell-command
       (concat "cat " filename " | ssh " hostname " 'cp .profile .profile.sergei.bak && cat - .profile >.profile.sergei.emacs.dired && cp .profile.sergei.emacs.dired .profile'"))))
#+END_SRC

* Grepping

I use simple grep commands to search through files:

- find+grep (=C-F=) to search in the current directory
- git-grep (=C-u C-F=) to search in the whole repository.

There are "modern" alternatives to these tools, like, =ack= and =ag=. But I
can't really appreciate the benefits they bring over the "stock" programs, i.e.
the benefits seam too small to me to bother. Simplicity and "always there"
aspects are much more valuable to me in that case.

If I want to limit the search, most of the time =git-grep= will be a decent
option. If I want to limit it even further, then I provide something like "-name
'*.c'" option to =find=.

#+BEGIN_SRC emacs-lisp
  (require 'vc-git)
  (require 'grep)

  (grep-apply-setting 'grep-find-command
                      (quote ("find . -type f -exec grep -nHi -e  {} +" . 35)))

  (defcustom git-grep-switches "--extended-regexp -I -n --ignore-case "
    "Switches to pass to 'git grep'."
    :type 'string
    :group 'grep)

  (defun git-grep (re)
    (interactive
     (list (let ((gg-init-value
                  ;; if region is active - use its value as an init
                  (if (region-active-p)
                      (buffer-substring-no-properties (region-beginning) (region-end))
                    nil)))
             (read-from-minibuffer "git grep: " gg-init-value nil nil 'grep-history))))
    (let ((grep-use-null-device nil))
      (grep (format "git --no-pager grep %s -e %s -- %s"
                    git-grep-switches
                    re
                    (expand-file-name (vc-git-root default-directory))))))

  (define-key global-map [(control shift f)]
    (defun grep-dispatch (arg)
      "With prefix calls `git-grep' and `find-grep' otherwise"
      (interactive "P")
      (if arg
          (call-interactively 'git-grep)
        (call-interactively 'find-grep))))
#+END_SRC

Grep buffer with clickable links is definitely a great feature. What makes it
super great is the ability to press =C-x C-q= and edit the contents of the
buffer, provided by =wgrep= package.

#+BEGIN_SRC emacs-lisp
  (eval-after-load "wgrep-autoloads"
    '(progn
       (when (require 'wgrep nil t)
         (setq wgrep-enable-key "\C-x\C-q")
         (add-hook 'grep-mode-hook
                   '(lambda ()
                      (define-key grep-mode-map "\C-c\C-c"
                        'wgrep-save-all-buffers))))))
#+END_SRC

* Hide/show blocks

There are some situations when you want to have a glance of functions defined in
a file. For elisp, you can use a trick, like =M-x occur defun=. Something like
Python could also be approached with a similar solution. But it's not that easy
to do so for the C-family languages. And that's where the =hideshow= module can
help you.

It has plenty of decent functions for collapsing code blocks. For example,
=hs-hide-all=, which is supposed to solve the aforementioned problem. But it
doesn't really work very well beyond the C language itself. Consider, for
example, a C++ file which defines all the symbols inside a namespace, or a Java
file with a class definition. Those files have just a single top-level entry,
which is not very informative.

So, I came up with this little function, that serves pretty much every need I
have regarding the hiding functionality, bound to =C-c h= in C-derived modes.

First of all, it's a toggling function - so, on one execution it collapses
blocks and on the next one it expands those. For collapsing, it uses every
top-level block inside the current one.

E.g. if you're at the top level of a C file, then it will leave only function
definitions. If you're inside a function, it will collapse every inner block /in
that function/. If you're inside a block, that's inside a function, it will
collapse every inner block /in that block/ and so on.

#+BEGIN_SRC emacs-lisp
  (defvar hs-hide-all-toggle-state nil "Current state of hideshow for toggling all.")
  (make-variable-buffer-local 'hs-hide-all-toggle-state)
  (require 'hideshow nil t)
  (defun hs-toggle-hideshow-all (arg)
    "Toggle hideshow all. Prefix arg is the level of hiding."
    (interactive "P")
    (if (not arg)
        (setq arg 1))
    (setq hs-hide-all-toggle-state (not hs-hide-all-toggle-state))
    (if hs-hide-all-toggle-state
        (hs-hide-level arg)
      (hs-show-all)))

  (add-hook 'c-mode-common-hook
            '(lambda ()
               (hs-minor-mode t)
               (define-key c-mode-base-map "\C-ch" 'hs-toggle-hideshow-all)))
#+END_SRC

* Upcoming sections
** Org
*** Presentations with reveal.js

There's a nice "framework" (or something) for creating presentations using plain
text files - reveal.js.

Originally, you were supposed to write the content in HTML, but know you can use
a lot of popular lightweight markups, like Org or Markdown.

To create a presentation using Org, you should:

- =git clone https://github.com/hakimel/reveal.js.git=
-

#+BEGIN_SRC emacs-lisp
  (eval-after-load "org-autoloads"
    '(progn
       (when (require 'org nil t)
         ;; enable python execution in org-mode
         (require 'ob-python)
         (require 'ob-R)
         (require 'ox-reveal)

         (defun conditional-org-reveal-export-to-html ()
           (save-excursion
             (beginning-of-buffer)
             (when (search-forward "#+REVEAL" nil nil)
               (org-reveal-export-to-html))))

         (add-hook 'org-ctrl-c-ctrl-c-final-hook
                   'conditional-org-reveal-export-to-html))))
#+END_SRC
*** Permanent table of contents

Org has a built-in way to generate a table of contents when exporting. However,
sometimes you need a table of contents in the raw org file. For example, when
you use it as a readme file in a GitHub repository.

I wrote a simple package serving this need.

In 2 words, you simply add a =:TOC:= tag to a heading and it will be updated
with the current table of contents before each save.

#+BEGIN_SRC emacs-lisp
  (eval-after-load "org-toc-autoloads"
    '(progn
       (if (require 'org-toc nil t)
           (add-hook 'org-mode-hook 'org-toc-enable)
         (message "WARNING: org-toc not found"))))
#+END_SRC

** Expand region
** Tags
** Auto-completion
*** Overview
*** hippie-expand
*** auto-complete
*** abbrev/yasnippet
* Unstructured configuration

Right now this section is simply a copy-paste of my old configuration. I
gradually move things from this section to separate ones.

#+BEGIN_SRC emacs-lisp
  ;; ------------------------------------------------------------
  ;; BUILT-IN DEPENDENCIES

  ;; hippie-expand
  (require 'hippie-exp)

  ;; ------------------------------------------------------------
  ;; PER-PACKAGE CONFIGURATION

  (eval-after-load "auto-complete-autoloads"
    '(progn
       (when (require 'auto-complete nil t)
         (require 'auto-complete-config)

         (defun ac-expand-no-next ()
           "Try expand, and if expanded twice, complete."
           (interactive)
           (unless (ac-expand-common)
             (let ((string (ac-selected-candidate)))
               (when string
                 (if (equal ac-prefix string)
                     (ac-complete)
                   (ac-expand-string string (eq last-command this-command))
                   ;; Do reposition if menu at long line
                   (if (and (> (popup-direction ac-menu) 0)
                            (ac-menu-at-wrapper-line-p))
                       (ac-reposition))
                   (setq ac-show-menu t)
                   string)))))

         (ac-flyspell-workaround)
         (setq-default ac-use-comphist nil)
         (define-key ac-completing-map [tab] 'ac-expand-no-next)

         (defun ac-yasnippet-candidates-sorted-by-length ()
           "Sorts yasnippet candidates by length."
           (sort (ac-yasnippet-candidates) '(lambda (l r) (< (length l) (length r)))))

         (ac-define-source yasnippet
           '((depends yasnippet)
             (candidates . ac-yasnippet-candidates-sorted-by-length)
             (action . yas-expand)
             (candidate-face . ac-yasnippet-candidate-face)
             (selection-face . ac-yasnippet-selection-face)
             (symbol . "a")))

         (add-hook 'emacs-lisp-mode-hook
                   '(lambda ()
                      (auto-complete-mode t)
                      (setq ac-sources '(
                                         ac-source-yasnippet
                                         ac-source-features
                                         ac-source-functions
                                         ac-source-variables
                                         ac-source-symbols
                                         ac-source-words-in-same-mode-buffers
                                         ))))

         (when (and (require 'ac-dcd nil t) (require 'd-mode nil t))
           (if (and (executable-find ac-dcd-server-executable)
                    (executable-find ac-dcd-executable))
               (progn
                 (add-hook 'd-mode-hook
                           '(lambda ()
                              (auto-complete-mode t)
                              (ac-dcd-maybe-start-server)
                              (setq ac-sources '(
                                                 ac-source-yasnippet
                                                 ac-source-dcd
                                                 ac-source-words-in-same-mode-buffers
                                                 ))))
                 (define-key d-mode-map [remap find-tag]     'ac-dcd-goto-definition)
                 (define-key d-mode-map [remap pop-tag-mark] 'ac-dcd-goto-def-pop-marker)
                 (define-key d-mode-map (kbd "M-?")          'ac-dcd-show-ddoc-with-buffer)
                 (define-key d-mode-map (kbd "C-c i")        'ac-dcd-add-imports))
             (message "WARNING: dcd-server not found"))))))

  ;; expand-region
  (eval-after-load "expand-region-autoloads"
    '(progn
       (when (require 'expand-region nil t)

         (defun er/mark-inside-pairs ()
           (interactive)
           (ignore-errors
             (funcall (or (command-remapping 'backward-up-list) 'backward-up-list))
             (set-mark (save-excursion
                         (forward-char 1)
                         (skip-chars-forward er--space-str)
                         (point)))
             (forward-sexp)
             (backward-char)
             (skip-chars-backward er--space-str)
             (exchange-point-and-mark)))

         (defun er/mark-outside-pairs ()
           "Mark pairs (as defined by the mode), including the pair chars."
           (interactive)
           (if (er/looking-back-on-line "\\s)+\\=")
               (ignore-errors (backward-list 1))
             (skip-chars-forward er--space-str))
           (when (or (not (er--looking-at-pair))
                     (er--looking-at-marked-pair))
             (funcall (or (command-remapping 'backward-up-list) 'backward-up-list)))
           (when (er--looking-at-pair)
             (set-mark (point))
             (forward-sexp)
             (exchange-point-and-mark)))

         (setq er/try-expand-list
               '(er/mark-word
                 er/mark-symbol
                 er/mark-inside-quotes
                 er/mark-outside-quotes
                 er/mark-inside-pairs
                 er/mark-outside-pairs
                 er/mark-comment
                 er/mark-url
                 er/mark-email
                 er/mark-defun))

         (add-hook 'text-mode-hook
                   '(lambda ()
                      (setq-local er/try-expand-list (remove 'er/mark-text-sentence er/try-expand-list))
                      (setq-local er/try-expand-list (remove 'er/mark-text-paragraph er/try-expand-list)))
                   t)
         (add-hook 'org-mode-hook
                   '(lambda ()
                      (setq-local er/try-expand-list (remove 'er/mark-sentence er/try-expand-list))
                      (setq-local er/try-expand-list (remove 'er/mark-text-sentence er/try-expand-list)))
                   t)

         (when (require 'd-mode nil t)
           (er/enable-mode-expansions 'd-mode 'er/add-cc-mode-expansions))

         (global-set-key (kbd "C-=") 'er/expand-region)
         (setq expand-region-fast-keys-enabled nil))))

  (eval-after-load "yasnippet-autoloads"
    '(progn
       (if (require 'yasnippet nil t)
           (progn
             (let ((yas-dir "~/.yasnippets"))
               (when (file-exists-p yas-dir)
                 (setq yas-snippet-dirs (list yas-dir))))
             (yas-global-mode 1)

             (add-hook 'term-mode-hook
                       '(lambda ()
                          (yas-minor-mode -1))))
         (message "WARNING: yasnippet not found"))))

  ;; ox-reveal
  ;; export .org files as reveal.js presentations (https://github.com/hakimel/reveal.js/)
  (require 'ox-reveal nil t)

  (require 'ert)
  (define-key ert-results-mode-map "g"
    'ert-results-rerun-all-tests)

  ;; ------------------------------------------------------------
  ;; DEFUNS

  (defun increment-decimal-number-at-point (&optional arg)
    "Increment the number at point by `arg'."
    (interactive "p*")
    (save-excursion
      (save-match-data
        (let (inc-by field-width answer)
          (setq inc-by (if arg arg 1))
          (skip-chars-backward "0123456789")
          (when (re-search-forward "[0-9]+" nil t)
            (setq field-width (- (match-end 0) (match-beginning 0)))
            (setq answer (+ (string-to-number (match-string 0) 10) inc-by))
            (when (< answer 0)
              (setq answer (+ (expt 10 field-width) answer)))
            (replace-match (format (concat "%0" (int-to-string field-width) "d")
                                   answer)))))))

  (defun parent-directory (dir)
    "Returns parent directory of dir"
    (when dir
      (file-name-directory (directory-file-name (expand-file-name dir)))))

  (defun search-file-up (name &optional path)
    "Searches for file `name' in parent directories recursively"
    (let* ((file-name (concat path name))
           (parent (parent-directory path))
           (path (or path default-directory)))
      (cond
       ((file-exists-p file-name) file-name)
       ((string= parent path) nil)
       (t (search-file-up name parent)))))

  (defun update-tags-file (arg)
    "Suggests options to update the TAGS file via ctags.

  With prefix arg - makes a call as sudo. Works for remote hosts
  also (>=23.4)"
    (interactive "P")
    (let ((tags-file-name
           (read-file-name
            "TAGS file: " (let ((fn (search-file-up "TAGS" default-directory)))
                            (if fn
                                (parent-directory fn)
                              default-directory))
            nil nil "TAGS"))
          (ctags-command "")
          (languages (cl-case major-mode
                       ((cc-mode c++-mode c-mode) "--languages=C,C++")
                       ((d-mode) "--languages=D")
                       (t ""))))
      (when tags-file-name
        (setq ctags-command (concat ctags-command "cd " (replace-regexp-in-string ".*:" "" (file-name-directory tags-file-name)) " && ")))

      (setq ctags-command (concat ctags-command "ctags -e " languages " -R . "))

      (with-temp-buffer
        (when arg
          (cd (add-sudo-to-filename (expand-file-name default-directory))))
        (shell-command (read-from-minibuffer "ctags command: "  ctags-command)))
      (visit-tags-table tags-file-name)))

  (define-key global-map [remap open-line]
    (defun open-line-indent (arg)
      "Use newline-and-indent in open-line command if there are
  non-whitespace characters after the point"
      (interactive "P")
      (save-excursion
        (if (looking-at-p "\\s-*$") ;; how in earth does this work?
            (newline arg)
          (newline-and-indent)))))

  (defun notify-send (title msg &optional icon)
    "Show a popup; TITLE is the title of the message, MSG is the
  context. ICON is the optional filename or keyword.
  Portable keywords are: error, important, info."
    (interactive)
    (if (or (eq window-system 'x)
            (eq window-system 'w32))
        (save-window-excursion
          (async-shell-command (concat "notify-send "
                                       (if icon (concat "-i " icon) "-i important")
                                       " \"" title "\" \"" msg "\"")))
      ;; text only version
      (message (concat title ": " msg))))

  (defcustom pop-predefined-register ?}
    "Register for saving window configuration before jump"
    :type 'register
    :group 'ediff)

  (define-key global-map [remap jump-to-register]
    (defun jump-to-register-with-save (register &optional delete)
      "Like jump-to-register, but saves current window configuration
  to predefined register"
      (interactive "cJump to register: \nP")
      ;; autosave current window configuration unless we're jumping back
      (unless (equal register pop-predefined-register)
        (window-configuration-to-register pop-predefined-register))
      (jump-to-register register delete)))

  (require 'etags)
  (defun find-function-push-tag (function)
    "This function is meant as a drop-in replacement for find-tag
  in emacs-lisp-mode. It calls find-function and inserts current
  position into find-tag-marker-ring."
    (interactive (find-function-read))
    (ring-insert find-tag-marker-ring (point-marker))
    (find-function function))

  ;; ------------------------------------------------------------
  ;; CUSTOMIZED

  (custom-set-variables
   ;; custom-set-variables was added by Custom.
   ;; If you edit it by hand, you could mess it up, so be careful.
   ;; Your init file should contain only one such instance.
   ;; If there is more than one, they won't work right.
   '(async-shell-command-buffer (quote new-buffer))
   '(c-basic-offset 4)
   '(c-default-style (quote ((c-mode . "bsd") (c++-mode . "bsd") (d-mode . "bsd") (java-mode . "java") (awk-mode . "awk") (other . "gnu"))))
   '(calendar-week-start-day 1)
   '(compilation-scroll-output (quote first-error))
   '(confirm-kill-emacs (quote y-or-n-p))
   '(create-lockfiles nil)
   '(default-input-method "russian-computer")
   '(diff-update-on-the-fly nil)
   '(frame-background-mode (quote dark))
   '(hippie-expand-try-functions-list (quote (try-complete-file-name-partially try-complete-file-name try-expand-all-abbrevs try-expand-dabbrev try-expand-dabbrev-all-buffers try-expand-dabbrev-from-kill)))
   '(indent-tabs-mode nil)
   '(initial-major-mode (quote emacs-lisp-mode))
   '(initial-scratch-message nil)
   '(ls-lisp-dirs-first t)
   '(ls-lisp-ignore-case t)
   '(ls-lisp-verbosity nil)
   '(org-agenda-files (quote ("~/Dropbox/Private/org/")))
   '(org-clock-mode-line-total (quote current))
   '(org-confirm-babel-evaluate nil)
   '(org-directory "~/Dropbox/Private/org")
   '(org-hide-leading-stars t)
   '(org-modules (quote (org-bbdb org-bibtex org-docview org-gnus org-info org-jsinfo org-habit org-irc org-mew org-mhe org-rmail org-vm org-wl org-w3m)))
   '(org-src-fontify-natively t)
   '(org-startup-indented t)
   '(org-support-shift-select (quote always))
   '(read-buffer-completion-ignore-case t)
   '(read-file-name-completion-ignore-case t)
   '(scroll-conservatively 1)
   '(scroll-error-top-bottom t)
   '(show-paren-delay 0)
   '(tab-width 4)
   '(tags-case-fold-search nil)
   '(truncate-lines t)
   '(whitespace-style (quote (face tabs trailing space-before-tab newline indentation empty space-after-tab tab-mark newline-mark)))
   '(yas-prompt-functions (quote (yas-dropdown-prompt yas-ido-prompt yas-completing-prompt yas-x-prompt yas-no-prompt))))

  ;; ------------------------------------------------------------
  ;; KEY BINDINGS

  ;; global
  (global-set-key (kbd "C-x f")       'find-file)
  (global-set-key (kbd "C-M-p")       'backward-paragraph)
  (global-set-key (kbd "C-M-n")       'forward-paragraph)
  (global-set-key (kbd "C-M-l")       'recenter-top-bottom)
  (global-set-key (kbd "\C-c c")      'org-capture)
  (global-set-key (kbd "\C-c a")      'org-agenda)
  (global-set-key (kbd "M-P")         'scroll-down-line)
  (global-set-key (kbd "M-N")         'scroll-up-line)
  (global-set-key (kbd "M-\"")        'double-quote-word)
  (global-set-key (kbd "\C-x v a")    'vc-annotate)
  (global-set-key (kbd "\C-x v b")    'vc-annotate)
  (global-set-key (kbd "<f5>")        'revert-buffer)
  (global-set-key (kbd "M-\\")        'fixup-whitespace)
  (global-set-key (kbd "M-/")         'hippie-expand)
  (global-set-key (kbd "\C-x k")      'kill-this-buffer)
  (global-set-key (kbd "C-+")         'org-list-repair)
  (global-set-key (kbd "M-+")         'org-list-repair)
  (global-set-key (kbd "C-x w")       'webjump)
  (global-set-key (kbd "C-x t")       'toggle-truncate-lines)
  (global-set-key (kbd "M-Z")         'zap-up-to-char)
  (global-set-key (kbd "\C-c\C-o")    'find-file-at-point)
  (global-set-key (kbd "C-z")         'undo)
  (global-set-key [escape]            'keyboard-escape-quit)
  (global-set-key "\C-x\C-u"          'update-tags-file)
  (global-set-key "\C-x\C-v"          'visit-tags-table)
  (global-set-key "\C-x\C-t"          'tags-reset-tags-tables)
  (global-set-key "\C-x\C-l"          'tags-apropos)
  (global-set-key "\C-c\C-c"          'compile)
  (global-set-key "\C-c+"             'increment-decimal-number-at-point)

  ;; C-/ is not representable with an ASCII control code, so it cannot be sent to
  ;; terminals, but it is a convenient keybinding for undo. So mapping it to
  ;; "traditional" undo sequence C-_ is a cute way around
  (define-key key-translation-map [?\C-/] [?\C-_]) ;; translate C-/ to C-_

  ;; convenient binding for C-x C-s in org-src-mode
  (add-hook 'org-src-mode-hook
            '(lambda ()
               (define-key org-src-mode-map (kbd "C-x C-s") 'org-edit-src-save)
               (define-key org-src-mode-map (kbd "C-x k")   'org-edit-src-exit)))

  (add-hook 'shell-mode-hook
            '(lambda ()
               (define-key shell-mode-map (kbd "\C-c\C-o") nil)))

  (add-hook 'org-mode-hook
            '(lambda ()
               ;; don't redefine some bindings
               (define-key org-mode-map [C-tab]
                 nil)
               (define-key org-mode-map (kbd "M-h")
                 nil)
               ;; swap active/inactive time-stamp bindings
               (define-key org-mode-map (kbd "C-c .")
                 'org-time-stamp-inactive)
               (define-key org-mode-map (kbd "C-c !")
                 'org-time-stamp)))

  (add-hook 'conf-mode-hook
            '(lambda ()
               (define-key conf-mode-map "\C-c\C-c"
                 nil)))

  (add-hook 'sh-mode-hook
            '(lambda ()
               (define-key sh-mode-map "\C-c\C-c"
                 nil)
               (define-key sh-mode-map "\C-c\C-o"
                 nil)))

  (add-hook 'emacs-lisp-mode-hook
            '(lambda ()
               (define-key emacs-lisp-mode-map (kbd "M-.")
                 'find-function-push-tag)))

  (add-hook 'tar-mode-hook
            '(lambda ()
               (define-key tar-mode-map (kbd "g")
                 (defun revert-buffer-without-query ()
                   (interactive)
                   (revert-buffer nil t)))))

  (add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
  (add-to-list 'auto-mode-alist '("\\.c\\'" . c++-mode))
  (add-hook 'c-mode-common-hook
            '(lambda ()
               (define-key c-mode-base-map "\C-c\C-o"
                 'ff-find-other-file)

               (define-key c-mode-base-map "\C-c\C-c"    nil)
               (define-key c-mode-base-map (kbd "C-M-h") nil)
               (define-key c-mode-base-map (kbd "M-j")   nil)

               ;; hs-mode
               (hs-minor-mode t)
               (define-key c-mode-base-map "\C-ch"
                 'hs-toggle-hideshow-all)
               ;; set //-style comments for c-mode
               (setq comment-start "//" comment-end "")))

  (add-to-list 'auto-mode-alist '("\\.m\\'" . octave-mode))

  (add-to-list 'auto-mode-alist '("\\.abbrev_defs\\'" . emacs-lisp-mode))

  (add-to-list 'auto-mode-alist '("\\.log\\'" . auto-revert-tail-mode))

  ;; ------------------------------------------------------------
  ;; MISCELLANEOUS CONFIGS

  ;; write backup files to own directory
  (setq backup-directory-alist
        `(("." . ,(expand-file-name
                   (concat user-emacs-directory "backups")))))
  ;; make backups of files, even when they're under version control
  (setq vc-make-backup-files t)

  (require 'server)
  (when (equal window-system 'w32)
    ;; Suppress error "directory ~/.emacs.d/server is unsafe" on
    ;; windows.
    (defun server-ensure-safe-dir (dir) "Noop" t))

  ;; start emacs server on first run
  (unless (server-running-p) (server-start))
  ;; do not disturb with "buffer still has active clients" on buffer killing
  (remove-hook 'kill-buffer-query-functions 'server-kill-buffer-query-function)

  ;; ftp dumb hosts
  (setq-default ange-ftp-dumb-unix-host-regexp
                (regexp-opt '(
                              "files.itseez.com"
                              )))

  ;; disable 'confusing' functions disabling
  (put 'narrow-to-region 'disabled nil)

  ;; shut up the bell
  (setq ring-bell-function 'ignore)

  ;; delete trailing whitespace before save
  (add-hook 'before-save-hook 'delete-trailing-whitespace)

  ;; show matching parentheses
  (show-paren-mode 1)

  ;; replace selection with input or yank
  (delete-selection-mode 1)

  ;; Show keystrokes in progress
  (setq echo-keystrokes 0.01)

  ;; Allow recursive minibuffers
  (setq enable-recursive-minibuffers t)

  ;; Revolt, outrage, revolution! No double spaces in the end of sentences.
  (set-default 'sentence-end-double-space nil)

  ;; Disable electric indent mode
  (electric-indent-mode -1)

  ;; make backspace to always delete chars
  (define-key isearch-mode-map [remap isearch-delete-char] 'isearch-del-char)
  (define-key isearch-mode-map [escape] 'isearch-cancel)

  ;; Answering just 'y' or 'n' will do
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

# Local Variables:
# compile-command: "emacs -batch -l org -l ob-tangle --eval \"(find-file \\\"/home/sergei/.dev-setup/dot-emacs/emacs-init.org\\\")\" --eval \"(org-babel-tangle nil \\\"/tmp/emacs-init-compile.el\\\")\" --eval \"(batch-byte-compile-file \\\"/tmp/emacs-init-compile.el\\\")\" 2>&1 | sed -n '/Warning\\|Error/p' | xargs -r ls"
# End:
