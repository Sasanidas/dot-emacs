#+TITLE: Об одном текстовом редакторе
#+AUTHOR: Сергей Носов
#+EMAIL: sergei.nosov@gmail.com
#+LATEX_HEADER: \usepackage[T2A]{fontenc}
#+LATEX_HEADER: \usepackage[russian]{babel}
#+LATEX_HEADER: \usepackage[cm]{fullpage}
#+LATEX_HEADER: \usepackage[num,english]{isodate}
#+LATEX_HEADER: \addto{\captionsenglish}{\renewcommand*{\contentsname}{Содержание}}

* Введение

В данном репозитории находится конфигурация редактора [[https://www.gnu.org/software/emacs/][Emacs]], которую я использую
в своей профессиональной деятельности. В первую очередь она включает в себя
разработку программного обеспечения, а также всё, что с этим связано -
исследование, администрирование, тестирование, отладка, написание статей,
презентаций, документации и т.п.

Ниже приведено достаточно полное описание возможностей Emacs и того, как ими
пользоваться. Поскольку возможностей у него довольно много, то и соответствующее
описание имеет внушительный объем, вдумчивое знакомство с которым может занять
не один день работы.

Но я постарался подумать обо всех - в том числе и о тех, у кого нет времени
читать всякие там инструкции - поэтому структурировал изложение следующим
образом:

- Если тебе просто нужен текстовый редактор, то чтение можно ограничить секциями
  "Установка", "Обозначения" и "Начало работы" (совсем небольшими по объему).
- Если ты уже начал использовать Emacs и хотел бы узнать побольше о его основных
  возможностях - к прочтению рекомендуются все разделы вплоть до "Специальных
  возможностей". Думаю, что на их освоение уйдет один дождливый или морозный
  выходной.
- Если ты овладел основными возможностями Emacs и хочешь узнать о более
  продвинутых способах его использования - можно продолжать чтение до конца.
  Среди прочего там будет рассмотрено и как написать первую в жизни программу.

* Содержание                                                   :TOC:noexport:
 - [[#Введение][Введение]]
 - [[#Установка][Установка]]
 - [[#Предисловие][Предисловие]]
 - [[#Минимальные-требования][Минимальные требования]]
     - [[#Слепая-печать][Слепая печать]]
     - [[#caps-lock---третий-ctrl][Caps Lock - третий Ctrl]]
     - [[#Переключение-языка-на-shift-shift][Переключение языка на Shift-Shift]]
 - [[#Обозначения][Обозначения]]
 - [[#Начало-работы][Начало работы]]
 - [[#Файловый-менеджер][Файловый менеджер]]
 - [[#Окна-и-буферы][Окна и буферы]]
     - [[#Определения][Определения]]
     - [[#Список-буферов][Список буферов]]
     - [[#Работа-с-окнами][Работа с окнами]]
     - [[#Строка-состояния][Строка состояния]]
 - [[#Базовые-операции][Базовые операции]]
 - [[#Работа-со-словами-и-другими-структурными-единицами][Работа со словами и другими структурными единицами]]
 - [[#ВырезатьВставить][Вырезать/Вставить]]
     - [[#Выделение-регионов][Выделение регионов]]
     - [[#Базовые-операции][Базовые операции]]
     - [[#Дополнительные-операции-вырезания][Дополнительные операции вырезания]]
 - [[#Префиксный-аргумент][Префиксный аргумент]]
     - [[#Численный-аргумент][Численный аргумент]]
     - [[#Отрицательный-аргумент][Отрицательный аргумент]]
     - [[#Универсальный-аргумент][Универсальный аргумент]]
 - [[#undoredo][Undo/Redo]]
 - [[#Поиск][Поиск]]
 - [[#Как-поставить-dmd][Как поставить dmd]]
 - [[#Пишем-презентацию-в-орг-моде-в-маркдауне-починить-нумерованый-список][Пишем презентацию в орг-моде, в маркдауне (починить нумерованый список)]]
 - [[#Разное][Разное]]
 - [[#Заключение][Заключение]]

* Установка

Для установки Emacs и его конфигурации, пользователи ОС [[http://www.ubuntu.com/][Ubuntu]] могут
воспользоваться следующей командой:

#+BEGIN_SRC sh
  wget http://git.io/e1TCJQ -O- | bash
#+END_SRC

Во время её выполнения устанавливается сам Emacs, клонируется данный репозиторий
и в домашнюю директорию добавляются символьные ссылки на файлы из репозитория.

Пользователи других ОС могут проделать эти шаги в ручную. Вместо создания
символьных ссылок, файлы можно просто скопировать в домашнюю директорию.

Для запуска нужно в терминале выполнить команду =emacs=, либо воспользоваться
любым другим способом, предоставляемым операционной системой.

* Предисловие

Если ты установил Emacs - ты уже на полпути к личному успеху. Теперь ты можешь
делать в нём ВСЁ, ЧТО УГОДНО! Во истину, захватывающие возможности - но не
исключено, что кому-то интересен более конкретный ответ на вопрос "Куды бечь и
что делать?".

Как раз для таких людей написан этот небольшой обзор. Возможно, ты вообще
никогда ничего не программировал в своей жизни и при работе с компьютером
ограничивался браузером и меню компьютерных игр, а теперь тебе захотелось
написать свою собственную игру или сайт. Возможно, ты что-то программировал в
школе или университете, глядя в голубой экран с текстом на языке Паскаль и вот
сейчас в твоих висках неожиданно застучали воспоминания и огнём вспыхнули
дерзкие мысли. Возможно, ты программировал на C# в Visual Studio под Windows и
чувствуешь, что настоящая жизнь проходит мимо и отправился её искать.

Во всех этих случаях, а также, если ты обычный программист / администратор /
публицист / ..., который вдруг осознал, что написание и перестановка буковок на
экране занимает значительную часть твоего дня. Если ты задумался, почему ты
вынужден ставить десяток программ - каждую со своим текстовым редактором разной
степени убогости, для не очень-то разных задач. Если тебе непонятно, почему ты
должен к ним привыкать, воевать с ними и вообще пользоваться ими, то ты зашел по
адресу.

Не секрет, что редактирование текста - первейшая задача при работе за
компьютером и было бы странно, если бы она до сих пор не была решена. Ко
всеобщей радости, решили её давно - созданием Emacs.

А также попутно решили вопрос с тем, как человек может удобно организовать и
обработку созданного текста. Языки программирования приходят и уходят, а Emacs
остается. Языки вёрстки - LaTeX, HTML, Markdown - приходят и уходят - а Emacs
остается. Операционные системы приходят и уходят, а Emacs - прекрасно работает
на любой из них.

Кому-то может показаться, что я передергиваю и бессовестно пользуюсь рекламными
приемами. Однако, судите сами - за недолгую историю компьютеров и программного
обеспечения, мы уже привыкли к тому, что новые идеи и решения устаревают, едва
успев появиться. Поэтому, на мой взгляд, программа, рожденная в 1970-х годах,
которая до сих пор жива и работает, которую используют сотни тысяч людей по сей
день, как минимум, внушает интерес и доверие - по всей видимости, что-то в ней
сделано как следует.

* Минимальные требования

Этот довольно внушительный по объему раздел написан для тех читателей, которые
собираются всерьез подойти к изучению Emacs. В целом, без выполнения требований
этого раздела можно сразу начать им пользоваться, как обычным текстовым
редактором - большинство часто используемых команд можно найти в общепринятых
или легко доступных местах. Наиболее значимые исключения составляют клавиши
Ctrl-x, Ctrl-c и Ctrl-v, о чем можно прочитать в разделе "Начало работы".

Таким образом, если тебе не терпится начать работу - текущий раздел можно
пропустить.

Если же ты полон решимости стать суровым профессионалом, а не бестолковым
дилетантом, то позволь выразить тебе свое глубочайшее почтение и огласить весь
список, пожалуйста.

** Слепая печать

Ты должен научиться печатать вслепую. Точка. Точнее, восклицательный знак.

Переоценить важность этого навыка невозможно. Никакие программы, инструменты,
авто-дополнения, подсказки, интуитивно понятные интерфейсы не улучшат качество
твоей работы так, как слепая печать.

Конечно же, в целом, без слепой печати можно прожить - но выглядеть это будет,
как если бы ты перемещался, привязав правую ногу к левой веревкой.

Самый простой способ научиться - пройти курс [[http://ergosolo.ru/]["Соло на клавиатуре"]]. Первым делом
нужно пройти английский курс, после этого, по желанию - русский.

Если ты уже умеешь печатать вслепую, то можешь смело переходить к следующему
пункту. Если ты начал учиться слепой печати, то тоже можешь переходить к
следующему пункту, только помни - даже если ты ещё не можешь печатать не глядя,
держи обе руки на клавиатуре в правильном положении.

Если же ты не собираешься учиться печатать вслепую и тебе даже не стыдно, то у
меня есть ещё несколько слов.

Главный аргумент, почему люди не учатся печатать вслепую - "у меня и так всё
нормально".

Естественно, ничего у них не нормально. Дело в том, что когда говорят о слепой
печати - в первую очередь говорят о скорости набора. И те, кто научился двумя
пальцами набирать по 100 знаков в минуту, говорят, что они и так хорошо
справляются - быстрее не надо.

Действительно, со стороны, скорость - самый заметный и внешне привлекательный
аспект - но с практической точки зрения он интересен разве только
стенографисткам. Средний программист, к примеру, в день набирает около 100 (ста)
строк кода. Скорость, с которой он их наберет даже тыкая двумя пальцами по
клавиатуре - всего лишь небольшая толика 8ми-часового рабочего дня.

Может показаться, что 100 строк в день - заниженная оценка, но на самом деле она
легко объясняется. Как правило, программист гораздо больше думает о том, /что/
нужно написать, чем непосредственно пишет. То же самое можно сказать и о
писателе или журналисте. Человек не может сочинять текст на скорости 300
символов в минуту. Нужно подбирать слова, перечитывать написанное, переставлять
абзацы и предложения - именно это занимает большую часть времени.

Поэтому в навыке слепой печати намного важнее то, что человек перестает думать о
том, *КАК* он печатает и у него освобождается время для обдумывания того, *ЧТО*
нужно напечатать.

При печати двумя пальцами, человеку нужно перевести взгляд с монитора на
клавиатуру, а потом обратно, нужно найти буквы на клавиатуре. В результате фраза
"Добрый день" в голове превращается в "Lj,hs-блин, язык не
переключил,del,del,del,del,del-Д-о-б-р-ы-ы-ы-где-ы?-ы-й д-е-н-ь!". И к тому
времени, как человек её набрал он уже забыл, что хотел написать в письме.

Представь, также что ты вынужден был бы думать о том, как и когда делать вдохи и
выдохи - с большими шансами ты вообще не смог бы думать больше ни о чем другом,
а думал только как бы не задохнуться.

Таким образом, главный плюс слепой печати - среди прочих неоспоримых и важных
преимуществ - заключается в том, что печать для тебя становится навыком,
записанным на подкорке мозга - ты просто перестаешь о нем думать - как о ходьбе,
дыхании и проч.

Второй аргумент, почему люди не учатся печатать вслепую - "у меня нет времени на
обучение".

Этот аргумент ещё мощнее первого. "Вслепую я печатаю в три раза медленнее,
сбиваюсь и забываю клавиши, а мне нужно срочно писать курсовую/диплом/проект на
работе/...".

Прохождение курса "Соло на клавиатуре" в среднем занимает у человека 40 (сорок)
часов работы за клавиатурой (всё время занимает немногим больше). Наверное,
что-то с тобой не так, если для обретения навыка, который качественно улучшит
твою профессиональную деятельность до конца жизни, у тебя нет сорока часов. 40
часов - это один месяц по 2 часа в день, неделя - по 6 часов в день. Сколько
времени ты посвящаешь чтению новостей, просмотру YouTube, прослушиванию музыки и
т.п.?

Кроме того, представь, что тебе полгода и ты научился ползать по квартире. В год
родители тебя заставляют ходить - а ты им объясняешь, что можешь доползти куда
хочешь и тебе непонятно, зачем нужно ходить - перемещаешься ты гораздо
медленнее, постоянно падаешь, быстро устаешь. И где бы ты был, если бы в 20 лет
по-прежнему ползал и не умел ходить?

Третий аргумент. Многим кажется, что овладеть слепой печатью очень сложно.
Действительно, задуматься только - надо же запомнить порядка 30 клавиш, а если
печатать на 2х языках - то порядка 70. Их все нужно ПОСТОЯННО ПОМНИТЬ.

Главный секрет здесь - думать надо меньше. Я не зря всё время провожу аналогии с
ходьбой, дыханием и подобными действиями - все они управляются не сознанием, а
подсознанием. В процессе обучения - ты действительно будешь задумываться, где
расположена какая-то клавиша. Но эта информация очень быстро запишется под корку
и не будет требовать вообще никаких умственных усилий. Вообще никаких. Клавиши
будут нажиматься чисто машинально.

Кстати сказать, это ещё и положительно сказывается на количестве ошибок. В моем
детстве был мультфильм про сороконожку, которую спросили, как она управляется со
своими ногами, она ничего толком не ответила и ушла, но задумалась. И когда она
стала думать, как ей шагать - ноги у неё стали заплетаться и она постоянно
падала, а когда она отвлеклась, то спокойно пошла, как раньше.

Итак, надеюсь, я убедил тебя научиться печатать вслепую. Если после всех моих
стараний ты всё-таки решишь продолжить, печатая абы как, то хотя бы положи руки
на клавиатуру правильно и старайся жать кнопки правильными пальцами.

После того, как я прошел курс обучения на английском языке, по-русски я всё ещё
печатал глядя на клавиатуру. Но я привык держать руки правильно и однажды во
время печати меня осенило, что я уже около часа печатаю по-русски и ни разу не
поглядел на клавиатуру. Я стал придумывать слова, а мои пальцы сами их
набирали. Причем, для того, чтобы вспомнить, где находится какая-то конкретная
клавиша, мне приходилось подумать секунд 5, а текст набирался совершенно
непринужденно - при условии, что я думал о тексте, а не о клавишах.

Надеюсь, этот прием поможет и тебе, мой ленивый читатель.

** Caps Lock - третий Ctrl

Оставшиеся 2 пункта не потребуют 40 часов твоего времени. Фактически, они
потребуют всего пару минут твоего времени - с ними нужно будет просто смириться.

Первый из них - нужно изменить конфигурацию клавиатуры, чтобы Caps Lock выступал
в роли третьего Ctrl'а. С первого взгляда это может показаться диким, но это то,
что обязательно нужно сделать.

Во-первых, используешь ты Emacs или нет, Caps Lock - абсолютно бесполезная
кнопка, которая занимает одну из самых удобных позиций на клавиатуре. Объяснить
это чем-то кроме исторического недоразумения невозможно.

Вообще, раскладка клавиатуры, которая повсеместно используется сегодня -
т.н. QWERTY - сама по себе является историческим недоразумением. Она была
придумана во времена печатных машинок и одним из главных факторов, повлиявших на
её окончательный вид было то, что механические молоточки, которые выбивали
символы на бумаге, не должны были цепляться друг за друга и застревать. Для
этого буквы, которые в тексте часто встречаются слитно, старались развести как
можно дальше друг от друга.

Такие метрики, как частота использования клавиш, частота использования разных
пальцев, частота чередования рук, практически не учитывались при разработке
QWERTY - её просто делали такой, чтобы механическая машинка могла работать.

Одной из первых раскладок, которая попыталась исправить это недоразумение была
Dvorak - и сегодня именно она является второй самой используемой раскладкой. При
её разработке как раз учитывались все те факторы, которые я перечислил - самые
часто используемые символы поместили на средний ряд, постарались, чтобы часто
встречающиеся сочетания двух букв как можно чаще набирались разными руками и
т.д. А работоспособность механической машинки не учитывалась вовсе, потому что
их вытеснили клавиатуры.

Для набора текста раскладка Dvorak по всем параметрам лучше QWERTY. Все мировые
рекорды скорости до недавнего времени ставились только на ней. QWERTY не было
даже близко в рекордных таблицах.

И по уму, все уже давно должны были перейти на Dvorak, но реальность диктовала
свои условия - куда бы ты ни пришел - везде стоят только QWERTY-клавиатуры,
операционные системы не поддерживают других раскладок или их не очень просто
настроить. Плюс - многие полезные комбинации кнопок, например, отмена последнего
действия, вырезать, копировать, вставить, располагаются на Ctrl-Z, Ctrl-X,
Ctrl-C, Ctrl-V, и если сменить раскладку - то они разлетятся по всей клавиатуре.

Для преодоления этих трудностей относительно недавно была придумана раскладка
Colemak - которая сравнима по ключевым параметрам с Dvorak, но гораздо больше
похожа на QWERTY, чем Dvorak. В частности, названные клавиши - Z, X, C, V -
вообще остались на тех же местах. Всё это, плюс - поддержка современными
операционными системами, плюс - активная реклама, сделали Colemak третьей по
популярности на сегодняшний день.

Но для чего я это рассказываю? А для того, что создатели Colemak тоже заметили,
что Caps Lock - это бесполезная кнопка на отличном месте. И на её место они
посадили Backspace. Печатальщики-пьюристы, наверное, раскритиковали бы такое
решение, дескать, "настоящему печатальщику не нужен Backspace, потому что он не
совершает ошибок". Но, на мой взгляд, решение это, в целом, хорошее. И не
пользуйся я Emacs'ом - поступил бы точно так же. Однако самая часто используемая
не-буквенная клавиша при работе в Emacs - Ctrl, поэтому именно он заслуживает
самого удобного положения. А вопрос с Backspace'ом там решен по-другому.

Кроме того, раз уж мы рассматриваем вопрос в историческом контексте, то на
старых клавиатурах для Unix-овых терминалов Ctrl располагался именно на месте
Caps Lock'a. Либо, на некоторых вариантах - на месте нынешнего Alt'a - тоже в
легко досягаемой позиции. Что, собственно, и мотивировало его частое
использование в редакторах того времени, к которым относится Emacs.

Агитационный блок на этом закончен и теперь, самое главное - как же сделать так,
чтобы Caps Lock выполнял функцию Ctrl? Если ты - пользователь Ubuntu и
воспользовался для установки строчкой, приведенной в секции 'Установка', то у
меня для тебя хорошие новости! Тебе нужно просто перезагрузиться и, хочешь ты
того или нет, твой Caps Lock станет третьим Ctrl'ом. Всем остальным могу
порекомендовать самостоятельно заняться решением этого вопроса.

** Переключение языка на Shift-Shift

И последнее. Настоятельно рекомендую настроить переключение языков (с русского
на английский и наоборот) на сочетание Shift-Shift.

Дело в том, что в Emacs время от времени придется использовать сочетания,
предусматривающие одновременное нажатие Ctrl-Alt, Ctrl-Shift и Shift-Alt. И если
какая-то из этих комбинаций также переключает язык - то время от времени он
будет нечаянно переключаться.

Установочный скрипт не делает этого, так что даже пользователям Ubuntu придется
открыть настройки системы. Я в тебя верю, мой ответственный читатель!

* Обозначения

Единственное, что нужно обговорить перед тем, как перейти непосредственно к
работе - обозначения комбинаций клавиш:

1. =С-= обозначает =Ctrl=.
2. =M-= обозначает =Alt=. Пользователи продукции Apple могут не найти
   у себя такой кнопки, её место (насколько мне известно) занимает клавиша =Cmd=
   и именно она функционирует в роли =M-=.
3. =S-= обозначает =Shift=.

Эти символы участвуют в обозначении комбинаций клавиш, например:
- =C-n= означает =Ctrl-n=
- =C-x C-f= означает, что надо нажать =Ctrl-x= и потом =Ctrl-f=
  (=Ctrl= можно не отпускать между нажатиями =x= и =f=)
- =C-c f= - означает, что нужно нажать =Ctrl-c= и (с отпущенным
  =Ctrl=) нажать =f=

Самые часто используемые команды, такие как перемещение курсора, как правило,
выполняются нажатием одного модификатора и одной буквенной клавиши. При этом
буквенный символ чаще всего является мнемоническим, например, =C-n= -
переместить курсор на следующую строчку (next line). Для менее частых, но тоже
важных команд, как правило, используется префикс =C-x=, например, =C-x C-f= -
открыть файл (find file). Для схожих по частоте и важности команд, определенных
пользователем (т.е. при использовании данной конфигурации - определенных мной),
используется префикс =C-c=, например, =C-c C-o= - открыть файл (или
интернет-адрес), путь к которому находится под курсором.

Теперь можно начинать!

* Начало работы

Когда ты в первый раз запустишь Emacs, он предложит тебе установить недостающие
/пакеты/. Можно нажать =!= для того, чтобы согласиться на установку всего, что
нужно. После этого тебе откроется т.н. черновой /буфер/, в котором можно уже
что-нибудь напечатать.

Попробуй набрать небольшой абзац. Уверен, что у тебя всё получится без
дополнительных объяснений. Большинство распространенных команд и сочетаний
работают "как обычно".

Единственное, возможно, ты привык использовать кнопки Ctrl-x, Ctrl-c и Ctrl-v
при редактировании. В Emacs эти комбинации выполняют совсем другие
функции. Подробнее я расскажу о том, как устроены копирование и вставка в Emacs
позже, а первое время можно просто использовать следующие аналоги:

- =C-w= - /вырезать/
- =M-w= - /копировать/
- =C-y= - /вставить/

Эти комбинации могут показаться довольно странными, например, =C-y= трудно
нажать одной рукой, но если ты обе руки держишь на клавиатуре - то, в целом, они
самые обыкновенные. А поскольку отучиться пользоваться мышкой - второй по
важности для улучшения качества работы пункт (после слепой печати), то это даже
играет на пользу.

Теперь попробуем открыть какой-нибудь файл. Для этого используем комбинацию =C-x
C-f=. Внизу, в т.н. /минибуфере/ появится имя текущей директории и начало списка
находящихся в ней файлов.

По мере набора имени файла, будут оставаться только те варианты, которые
соответствуют набранным символам. Например, можно набрать "rdme", и если в
директории есть файл с именем "Readme.txt" (регистр не учитывается), то он
останется в числе кандидатов. При наборе можно пропускать символы, но порядок
должен оставаться тем же, что и в имени файла, т.е. если, набрать "drme", то
"Readme.txt" уже пропадет из списка кандидатов.

При открытии файла работают следующие команды:

- =Enter= - открыть подсвеченный файл или зайти в директорию
- =Backspace= - вверх на одну директорию
- =C-s= - следующий кандидат в списке
- =C-r= - предыдущий кандидат в списке
- =C-f= - переход к "простому" вводу имени файла (в частности,
  необходим для создания новых файлов)
- =~/= - домашняя директория
- =/-<символ>= - корневая директория

После внесения изменений, файл можно сохранить командой =C-x C-s= (save
file). Сохранить его с другим именем можно командой =C-x C-w= (write file).

Для простого поиска по файлу используются сочетания:

- =C-s= и =C-r= - поиск вперед и назад, соответственно (повторные нажатия
  переводят курсор к очередному кандидату)
- =C-g= или =ESC= - отмена поиска и возврат курсора в исходную позицию
- =C-m= или =Enter= - выход из поиска

Для выхода из Emacs используется сочетание =C-x C-c=.

Если вдруг ты что-то нажал и произошло нечто страшное - стали происходить
непонятные события и ты не знаешь что делать, попытаться вернуть всё на свои
места можно следующими способами:

- Для отмены последних редактирований (т.н. undo) можно воспользоваться
  сочетанием =C-z= или равнозначным ему =C-/= (подробнее об отмене - несколько
  позже).
- В остальных случаях можно попробовать нажать =C-g=, что для большинства команд
  означает "отмена", либо усиленный вариант отмены - =ESC=.

Теперь ты должен быть в состоянии пользоваться Emacs в повседневной жизни вместо
своего прошлого любимого текстового редактора, практически не изменяя старым
привычкам. Дальше пойдут бонусы.

* Файловый менеджер

Есть довольно известный в определенных кругах анекдот: "Из Emacs получилась бы
отличная операционная система, если бы в нём был нормальный текстовый редактор".
Я не буду подробно объяснять в чем же, собственно говоря, юмор, потому что
анекдот потеряет свою прелесть. Вместо этого я расскажу о встроенном в Emacs
файловом менеджере для подтверждения первой части анекдота.

Вообще, файловый менеджер - это самый первый инструмент для работы на
компьютере, с которым я познакомился. В те далекие годы, когда я не знал, как
написать даже самую простенькую программу, я, тем не менее, умел открыть голубой
экран Norton Commander'a и стремительно носиться по файлам и папкам без
использвания мышки - в чем и была главная задача файлового менеджера.

Для этих же целей в Emacs имеется свой собственный текстовый редактор - Dired
(directory editor). Открыть его можно нажатием =C-x C-j= (dired jump), при этом
ты окажешься в папке, в которой находится редактируемый в данный момент файл.
Если нажать =C-x C-j=, уже находясь в dired, то это перебросит тебя на
директорию выше - гораздо более удобная альтернатива беготне до строки с двумя
точками.

Единственное, что стоит ещё отметить, это то, что Dired не обновляет своё
содержимое автоматически. Т.е. если в какую-то директорию, открытую в Dired,
скопировать файл или создать в ней новый файл, то отображаемое содержимое
директории не изменится. Для того, чтобы обновить содержимое, используется
кнопка =g=.

На этом, признаться, я хочу закончить знакомство с dired, поскольку, на мой
взгляд, дальнейшая работа с ним не вызовет трудностей даже у самого
незамутненного пользователя.

Однако, смею заверить, что это лишь вершина айсберга - возможности dired гораздо
более широки. Dired - на удивление мощный, гибкий и гармоничный менеджер -
особенно элегантный на фоне своих аналогов - Norton Commander'a, FAR'a, Total
Commander'a и других. Но разговор об этом я буду вести после того, как опишу
другие базовые возможности Emacs.

* Окна и буферы
** Определения

Современные приложения - браузеры, редакторы и т.п. - позволяют пользователю
открыть несколько т.н. /вкладок/. Например, если ты гуляешь по интернету, то в
браузере у тебя одновременно открыты ВКонтакте, Твиттер, Фейсбук, Ю-тюб и ещё
много чего, чтобы ты, не дай Бог, не пропустил момент, когда кто-то пришлет тебе
веселую картинку или ролик.

В текстовых редакторах можно открыть сразу несколько файлов и переключаться
между ними по мере необходимости - например, если ты выборочно копируешь текст
из одного файла в другой.

В Emacs таких вкладок нету, но дело ведь не во вкладках. Важно то, что они
позволяют делать и как они позволяют организовать работу. Поэтому вместо них в
Emacs предусмотрен другой механизм для схожей функциональности, который я сейчас
опишу.

Но прежде, сделаю, надеюсь, последнюю оговорку.

Как и в приведенном примере, многие функции Emacs имеют более или менее
устоявшиеся аналоги в других программах. И у значительной части людей эта
непохожесть Emacs'a на то, что они видели ранее, вызывает, как минимум, вопросы,
а у кого-то даже отторжение.

Зачастую, причины, по которым в Emacs что-то сделано определенным образом,
являются чисто историческими. Например, поскольку на UNIX-терминалах 1970-х
годов не было ни мышек, ни даже графических интерфейсов, придумать и реализовать
вкладки в их современном виде тогда не пришло бы никому в голову.

Резонно заметить, что исторические причины едва ли являются хорошим обоснованием
целесообразности того или иного решения. Но если исторически сложившееся
решение, как минимум, предоставляет тот же функционал, то, на мой взгляд, если к
этому добавить ещё и пройденное испытание временем, измена своим привычкам
становится вполне оправданной.

Этим я хочу сказать, что как только тебе в голову начнут залезать предательские
мысли о том, что что-то в Emacs делается "не так, как должно бы" - гони их
прочь. Скорее всего, в тебе просто говорит привычка и нежелание учиться и
переучиваться. Практически во всех случаях после непродолжительного
использования и размышления становится понятно, что предложенное решение
является разумным, целостным, продуманным и вполне годным.

Конечно, идеальных решений не существует и, поразмыслив над какой-то проблемой,
возможно, ты только ещё больше убедишься в том, что решать её надо по-другому. В
этом случае мой совет такой - если ты пользуешься Emacs'ом меньше полугода -
просто прикуси губу и попытайся работать так, "как задумано композитором" (с)
Chet Atkins.

Если же ты уже считаешь себя продвинутым пользователем Emacs, то это хороший
повод для того, чтобы научиться настраивать его под свои нужды. Можно сказать,
что Emacs расширяем до бесконечности - его всегда можно заставить вести себя в
точности так, как ты хочешь. Во многом, именно эта особенность и обеспечила ему
такую долгую и счастливую жизнь. Подробнее я раскрою эту тему в соответствующем
разделе ближе к концу обзора.

А теперь вернемся к работе с окнами и буферами.

В Emacs есть 3 основных понятия, связанные с организацией рабочего
пространства - это /фрейм/ (frame), /окно/ (window) и /буфер/ (buffer).

\pagebreak

Рассмотрим диаграмму, на которой изображен пример рабочей сессии в Emacs.

#+BEGIN_EXAMPLE
  +-------------------------------------------------------------------------------------+
  | emacs@sergei-MS-7758                                                                |
  +-------------------------------------------------------------------------------------+
  | File Edit Options Buffers Tools Org Tbl Help                                        |
  +------------------------------------------+------------------------------------------+
  | #!/usr/bin/env rdmd                      | * Работа со словами и абзацами           |
  | // Computes average line length for      |                                          |
  | // standard input.                       | Работать в редакторе с отдельными символа→
  | import std.stdio;                        | эффективно, как умножение заменять сложен→
  |                                          | оперирует в голове отдельными символами, →
  | void main() {                            | единицами - словами, предложениями, абзац→
  |     ulong lines = 0;                     | программирования соответствует идентифика→
  |     double sumLength = 0;                | (либо функциям). Поэтому гораздо удобнее →
  |     foreach (line; stdin.byLine()) {     | которые оперируют с этими же структурными→
  |         ++lines;                         |                                          |
  |         sumLength += line.length;        | Если в посимвольных командах использовать→
  |     }                                    | позволит оперировать более сложными едини→
  |     writeln("Average line length: ",     |                                          |
  |         lines ? sumLength / lines : 0);  | - =M-f= - следующее слово (forward word) →
  | }                                        | - =M-b= - предыдущее слово (backward word→
  |                                          | - =M-a= - в начало предложения (выражения→
  |                                          | - =M-e= - в конец предложения (выражения)→
  +------------------------------------------+------------------------------------------+
  |1 U:--- lc.d    All L12   (D/l hs Abbrev) |2:U:**- README.org     84% L472           |
  +------------------------------------------+------------------------------------------+
  | * Установка...                                                                      |
  | * Предисловие...                                                                    |
  | * Минимальные требования                                                            |
  |                                                                                     |
  |   Список того, что требуется от читателя - совсем небольшой - но очень              |
  |   важный:                                                                           |
  |                                                                                     |
  |   - Во-первых, ты должен научиться печатать вслепую. Переоценить                    |
  |     важность этого навыка невозможно. Никакие программы, инструменты,               |
  |     авто-дополнения, подсказки, интуитивно понятные интерфейсы не улучшат           |
  |                                                                                     |
  |     Конечно же, в целом, без этого можно прожить - но выглядеть это будет           |
  +-------------------------------------------------------------------------------------+
  |3 U:**- README.org     2% L120        (Org Ind ARev)                                 |
  +-------------------------------------------------------------------------------------+
  |                                                                                     |
  +-------------------------------------------------------------------------------------+
#+END_EXAMPLE

Всё, что изображено на приведенной диаграмме помещено в одном
фрейме. Т.е. фрейм - это самая вместительная сущность в Emacs. Новый фрейм
создается выполнением команды =emacs= в терминале.

Внутри фрейма могут создаваться окна - контейнеры, отвечающие за его
"геометрическую организацию". На приведенной диаграмме окна пронумерованы - их
номера записаны в самом начале т.н. /строки состояния/ (modline) - =1 U:--- lc.d
<...>=.

В каждом окне отображен какой-либо буфер. О буфере можно упрощенно думать, как
об открытом файле (в Emacs бывают не только файловые буферы, но в рамках данного
вопроса они ничем существенным не отличаются).

Ещё раз обращаю внимание, что окна - чисто геометрические сущности, а буферы
наполняют их содержанием.

Например, в первом окне отображен буфер, соответствующий файлу "lc.d", что
отражено в строке состояния. А буфер, соответствующий файлу "README.org"
отображен сразу в двух окнах - втором и третьем, причем отображают они разные
части файла. Но поскольку это один и тот же буфер, его изменеие в одном окне
влияет на содержимое другого.

** Список буферов

Для того, чтобы создать буфер, нужно просто открыть файл. Как уже оговаривалось,
сделать это можно командой =C-x C-f=.

Для переключения между буферами используется комбинация =C-<TAB>=, для закрытия
буфера - =C-x k=.

Если во время выбора буфера или файла ты вдруг передумал открывать что-либо, то
можно нажать =C-g=. Повторюсь, что эта комбинация означает "отмена" не только в
этом случае, но и для большинства нетривиальных команд Emacs.

Открыв несколько файлов, можно получить список всех буферов с помощью клавиш
=C-x C-b=, который выглядит примерно следующим образом:

#+BEGIN_EXAMPLE
    MR Name                    Size Mode             Filename/Process
    -- ----                    ---- ----             ----------------
   [ org ]
       README.org             36003 Org              ~/.dev-setup/dot-emacs/README.org
   [ dired ]
   [ D ]
   [ C/C++ ]
   [ magit ]
   [ Markdown ]
   [ emacs ]
    *  *Messages*               554 Fundamental
   [ shell commands ]
   [ Default ]
    *  *shell*                   25 Shell            (shell run) ~/
       .emacs                 44231 Emacs-Lisp       ~/.dev-setup/dot-emacs/.emacs
       *scratch*                  0 Emacs-Lisp
       config                   337 Conf[Space]      ~/.ssh/config
    *% *Compile-Log*            102 Special

       7 buffers              81252                  4 files, 1 process
#+END_EXAMPLE

В этом списке можно навести курсор на строчку с именем буфера и нажать =Enter=,
либо =C-m= для того, чтобы открыть соответствующий буфер.

Разберем, что указано в столбцах этого списка.

Расшифровка загадочного названия первого столбца - "Modified, Read-only". Если
буфер имеет несохраненные изменения, то первый символ в этом столбце - "*". Если
буфер нельзя редактировать, то второй символ в этом столбце - "%".

Во втором столбце указано имя буфера, в третьем - размер содержимого буфера в
байтах.

В четвертом столбце указан основной /режим/ (mode) буфера. Существуют, например,
режимы для редактирования файлов с программами на языках С++, D, Python и т.д.;
есть режимы для редактирования HTML, LaTex; есть также специальные режимы,
которые предназначены не для редактирования файлов, а для взаимодействия с
другими программами, например, для просмотра директорий или выполнения команд в
терминале.

Основной режим определяет способы редактирования и отображения буфера. Например,
в языке программирования С++ есть такие ключевые слова, как inline, const,
class, struct и др. И если открыть файл с программой на С++, то эти слова
выделятся специальным цветом. А в языке Python, например, слова inline, const и
struct не являются ключевыми, в то время как слова class, in, elif и др. -
являются. Для того, чтобы выделить ключевые слова корректно, буферы с файлами на
языках C++ и Python будут открыты в разных режимах, каждый со своими
представлениями о том, какие слова считать ключевыми.

Как правило, режим, в котором открывается буфер определяется по расширению
файла. Например, в приведенном списке буферов, файл "README.org" открыт в режиме
Org, предназначенном для редактирования файлов с одноименной разметкой.

В последнем столбце указан полный путь до файла либо имя процесса, с которым
связан буфер.

Также в списке буферов присутствуют горизонтальные разделители в квадратных
скобках (например, "[С/C++]"), они объединяют файлы в группы по каким-то общим
признакам. Состав групп и используемые признаки могут настраиваться, но мы не
будем на этом сейчас останавливаться.

** Работа с окнами

Нередко при работе требуется, чтобы перед глазами одновременно было несколько
буферов или разные части одного и того же буфера. Для этого в Emacs и
предназначены окна.

Для работы с ними используются следующие команды:

- Создание
  - =C-x 2= - разделить текущее окно по горизонтали
  - =C-x 3= - разделить текущее окно по вертикали
- Уничтожение
  - =C-x 1= - уничтожить все окна, кроме текущего
  - =C-x 0= - уничтожить текущее окно
- Переход между окнами
  - =M-1=, =M-2=, =M-3= и т.д. - переход в окно с указанным номером
  - =C-x o= - переход в следующее окно (other window)

Пользуясь командами для создания и уничтожения, можно строить довольно
замысловатые конструкции из окон. Однако, лично у меня 95 процентов времени
открыто либо одно, либо два окна.

Такой подход разительно отличается от того, что предлагают практически все
современные "интегрированные среды разработки" (IDE). Рабочее пространство в
них, как правило, ужасно захламлено. Одновременно там отображается редактор
кода, дерево файловой системы, панели со всевозможными настройками, функциями и
проч. Думаю, что во многом по этой причине, я практически не встречал людей,
которые при работе в IDE открывают файлы одновременно в двух окнах, а
предпочитают переключаться между вкладками.

По моему же опыту, случаи, когда одновременно нужно смотреть сразу в три и более
мест встречаются, но довольно редки. Поэтому все эти дополнительные панели
просто создают бардак. Приятно посмотреть на рабочее место иного художника или
архитектора, когда все инструменты аккуратно лежат на своих местах и находятся
под рукой; когда на столе практически ничего нет и он предоставлен только листу
бумаги. И, наоборот, берет оторопь, когда видишь "творческий беспорядок",
заключающийся в том, что рабочий стол завален инструментами, лист положить
просто негде, карандаши и бумага разбросаны по комнате, а художник грязными
руками пытается изобразить шедевр, сидя на полу.

На мой взгляд, рабочее место человека является прямым отражением того, что у
него происходит в голове. И если рабочее место человека - это непонятная свалка,
то и в голове у него точно такая же свалка. Нарисовать в таких условиях картину
в стиле "героиновый сон" и сказать, что художник "так видит", наверное,
можно. Но вот создать архитектурный проект "на века", наверное, уже нельзя.

В этом свете очень кстати приходится то, что управление буферами и окнами в
Emacs обеспечивается парой элементарных команд. Даже если у тебя есть склонность
к плохой организации (у меня, например, эта склонность проступает очень даже
выпукло), твоё рабочее пространство всё равно будет довольно аккуратным, потому
что поддерживать порядок в Emacs проще, чем наводить беспорядок.

В конце отмечу, что поскольку чаще всего одновременно я использую не больше двух
окон, то переключаюсь между ними я при помощи комбинации =C-x o=, что позволяет
не держать в голове номер текущего окна. Кроме того, при наличии двух окон,
полезными оказываются следующие команды:

- =C-c f= - поменять вертикальное разделение на горизонтальное и
  наоборот (flip windows)
- =C-c s= - поменять местами буферы, отображаемые в окнах (swap
  buffers)

** Строка состояния

Единственное, что осталось не до конца разобрано в этой секции - формат строки
состояния. Она присутствует внизу каждого окна и, как следует из названия,
содержит информацию о текущем состоянии окна.

#+BEGIN_EXAMPLE
  3 U:**- README.org 2% L120 (Org Ind ARev)
#+END_EXAMPLE

Разберем её слева направо.

- =3= - номер окна
- =U= - кодировка текущего буфера; в данном случае - UTF-8
- =:= - разделитель
- =**-= - 3 символа, описывающие состояние буфера; возможные значения:
  - первый символ:
    - =-= или =*= - буфер доступен для редактирования
    - =%= - буфер доступен только для чтения
  - второй символ:
    - =-= - все изменения буфера сохранены
    - =*= - в буфере есть несохраненные изменения
  - третий символ:
    - =-= - буфер является локальным, т.е. соответствует файлу или
      процессу на том же компьютере, на котором запущен Emacs
    - =@= - буфер является удаленным, т.е. соответствует файлу или
      процессу на удаленном сервере
- =README.org= - имя буфера
- =2%= - позиция окна в буфере; 2 процента означают, что отображаемый в окне
  текст находится почти в самом начале буфера; также вместо числа процентов
  может быть указано: =Top= - окно отображает самое начало буфера, =Bot= - окно
  отображает самый конец буфера, =All= - окно отображает буфер целиком
- =L120= - символ =L= и номер строки, на которой находится курсор
- =(Org Ind ARev)= - перечень режимов, работающих в этом буфере;
  первым всегда указан основной режим, после чего указан неполный перечень
  дополнительных режимов

* Базовые операции

Начнем привыкать к хорошему с базовых вещей. Во-первых, нужно забыть про
стрелочки для перемещения курсора:

- =C-n= - вниз (next line)
- =C-p= - вверх (previous line)
- =C-f= - вперед (forward char)
- =C-b= - назад (backward char)

Любое перемещение рук с их рабочего положения - к стрелочкам,
PgUp-ам/PgDown-ам/Home-ам/End-ам - это работа от локтя, которая плохо
автоматизируется и менее энергоэффективна, чем работа пальцами. Поэтому в первую
очередь мы будем переучиваться использовать буквенные клавиши для выполнения
частых операций.

Вот эквиваленты других часто используемых команд:

- =C-a= - в начало строки (=Home=)
- =C-e= - в конец строки (=End=)
- =C-v= - вниз на величину экрана (=PgDown=)
- =M-v= - вверх на величину экрана (=PgUp=)
- =M->= - в конец буфера
- =M-<= - в начало буфера
- =C-h= - удалить символ слева от курсора (=Backspace=)
- =C-d= - удалить символ справа от курсора (=Delete=)
- =С-j= - перевод строки

Можно считать, что =С-j= - замена клавиши =Enter=, но с небольшой разницей. Если
задуматься, то =Enter=, вообще говоря, выполняет 2 функции - перевод строки и
"ввод". Например, если ты набираешь строку поиска в Гугл, то, нажав =Enter=, ты
выполняешь поиск, а не переводишь строку, т.е. в зависимости от ситуации,
=Enter= ведет себя тем или иным образом.

В Emacs эти две функции разнесены на разные кнопки. 95 процентов времени
используется именно =C-j= - для перевода строки. Кроме того, в тех ситуациях,
когда это не вызывает двусмысленности, =C-j= работает и как "ввод". Но в
некоторых ситуациях, которые мы встретим позже, нужно будет различать эти
функции - поэтому "ввод" в Emacs осуществляется на =C-m=.

Отдельно хочу отметить замечательную комбинацию =C-l=. При первом нажатии, она
устанавливает содержимое буфера так, чтобы курсор находился в самом центре
окна. При повторном нажатии, содержимое меняется, чтобы курсор оказался в самом
верху, а при третьем - в самом низу. Очень полезная и часто используемая
функция.

И последнее. При переключении языка ввода на русский, можно заметить, что
практически все разобранные в этой секции комбинации перестают работать - внизу
появляются сообщения вроде "C-т is undefined". В принципе, из этого сообщения
можно понять, что происходит, но остается вопрос, что делать. Ответ прост - для
переключения языка в Emacs нужно использовать комбинацию "C-\" - таким образом
язык переключается не на уровне системы, а на уровне Emacs. Т.е. в Emacs
попадают команды с латинскими буквами, но после того, как было нажато "C-\",
Emacs будет переводить символы латинского алфавита в соответствующие (в смысле
раскладок QWERTY-ЙЦУКЕН) символы русского алфавита.

* Работа со словами и другими структурными единицами

Работать в редакторе с отдельными символами примерно так же эффективно, как
умножение заменять сложением. Как правило, человек не оперирует в голове
отдельными символами, а оперирует структурными единицами - словами,
предложениями, абзацами, что в языках программирования соответствует
идентификаторам, выражениям и блокам (либо функциям). Поэтому гораздо удобнее
пользоваться командами, которые оперируют с этими же структурными единицами.

Если в посимвольных командах использовать клавишу =M-=, то это позволит
оперировать более сложными единицами:

- =M-f= - следующее слово (forward word)
- =M-b= - предыдущее слово (backward word)
- =M-a= - в начало предложения (выражения в языках программирования)
- =M-e= - в конец предложения (выражения)
- =M-h= - вырезать слово слева от курсора
- =M-d= - вырезать слово справа от курсора

Некоторые из этих команд могут быть ещё больше "усилены" добавлением
=C-=. Например, для перемещения по сбалансированным скобкам, в Emacs
используются команды:

- =C-M-f= - следующее "скобочное выражение" (forward sexp)
- =C-M-b= - предыдущее "скобочное выражение" (backward sexp)

Эти функции работают почти также, как и функции "следующее слово" и "предыдущее
слово", с тем исключением, что они расценивают выражение в круглых, фигурных или
прямоугольных скобках, а также строки в кавычках, за одну единицу. Т.е. если
перед курсором открывающаяся скобка и ты нажмешь =C-M-f=, то курсор переместится
к закрывающей скобке. Вывести курсор за пределы скобок, в которых он находится,
при помощи этих функций нельзя.

- =С-M-a= - в начало абзаца (функции в языках программирования)
- =С-M-e= - в конец абзаца (функции)

Абзацами в тексте называются группы символов, разделенные пустой строкой. В
языках программирования иногда тоже бывает удобно перемещаться по таким группам,
для этого там используются сочетания:

- =С-M-p= - предыдущая пустая строка (previous paragraph)
- =С-M-n= - следующая пустая строка (next paragraph)

Отмечу, что для обычного текста эти сочетания по функциональности ничем не
отличаются от перемещения между абзацами.

Таким образом, в Emacs выделяются следующие текстовые единицы:

- символы и строки (префикс =С-=)
- слова и предложения (префикс =M-=)
- скобочные выражения (префикс =С-M-=)
- абзацы (выражения и функции в языках программирования) (префикс
  =С-M-=)

При разговоре о скобочных выражениях необходимо также отметить команду =C-S-h=
(splice sexp). Она несколько выбивается из рассматриваемого ряда по
функциональности (а потому и по форме "аккорда" - использованием Shift вместо
Alt), но тем не менее слишком важна, чтобы не упомянуть её. Указанная комбинация
удаляет обрамляющие символы скобочного выражения, внутри которого находится
курсор. Т.е. если курсор находится внутри цитаты, заключенной в кавычки, то
=C-S-h= удаляет обе - открывающую и закрывающую. Эта команда позволяет легко
следить за тем, чтобы скобки (и кавычки) всегда были сбалансированы.

В завершение этой секции, я приведу последнюю команду, которая используется для
работы с языковыми единицами, и которую нечасто встретишь в других редакторах:

- =C-t= - поменять буквы слева и справа от курсора местами (transpose
  chars)
- =M-t= - поменять слова слева и справа от курсора местами (transpose
  words)

Не сказать, что эти функции используются очень часто, но лично у меня на душе
становится теплее, когда нет-нет да и получится их использовать. Кроме того, эти
функции обладают интересным свойством, если, например, использовать =M-t=
несколько раз подряд, то это будет иметь эффект, как будто ты "тащишь" слово
вперед по тексту.

* Вырезать/Вставить
** Выделение регионов

Важной функцией любого редактора является работа с областями текста, которые в
Emacs называются /регионами/. Для выделения регионов многие люди используют
мышку, более продвинутые - используют стрелочки с зажатой клавишей Shift. В
Emacs оба эти способа тоже работают, однако считаются неоптимальными.

Для выделения произвольного региона нужно нажать =C-SPC=, по-русски говоря,
Ктрл-Пробел. После этого при изменении положения курсора начнет выделяться
регион между текущим положением и положением, где находился курсор во время
нажатия =C-SPC=.

Для выделения всего буфера используется сочетание =C-x h= (mark whole buffer).

Для снятия выделения используется сочетание =C-g=, которое, как говорилось в
самом начале, для большинства команд обозначает "отмена".

Кроме такого способа, Emacs также предлагает выделение структурных единиц при
помощи комбинации =C-==. Разберем её работу на примере следующего отрывка:

#+BEGIN_EXAMPLE
  "А смею спросить, - продолжал он, - зачем изволили вы перейти из гвардии в
  гарнизон?" Я отвечал, что такова была воля начальства. "Чаятельно, за
  неприличные гвардии офицеру поступки", - продолжал неутомимый
  вопрошатель. "Полно врать пустяки, - сказала ему капитанша, - ты видишь,
  молодой человек с дороги устал; ему не до тебя...  (держи-ка руки
  прямее...). А ты, мой батюшка, - продолжала она, обращаясь ко мне, - не
  печалься, что тебя упекли в наше захолустье. Не ты первый, не ты
  последний. Стерпится, слюбится."  (А.С. Пушкин, "Капитанская дочка")
#+END_EXAMPLE

Допустим, курсор находится в середине последнего слова - "дочка". При
последовательных нажатиях =C-== будут выделены следующие регионы:

- дочка
- Капитанская дочка
- "Капитанская дочка"
- А.С. Пушкин, "Капитанская дочка"
- (А.С. Пушкин, "Капитанская дочка")
- При очередном нажатии отрывок будет выделен целиком.

Т.е. =C-== осуществляет последовательное /расширение региона/ (expand
region). Эта функция пытается увеличить выделенный регион, раздвигая его границы
к началу и концу структурных единиц, вмещающих текущее выделение. В приведенном
примере сначала выделяется слово, потом то, что находится внутри кавычек, потом
захватываются сами кавычки, потом - внутренность скобок, потом - сами скобки и,
наконец, весь фрагмент.

Структурными единицами являются:

- слова
- внутренности скобок и кавычек
- внутренности скобок и кавычек вместе с обрамляющими символами
- абзацы
- весь буфер

Кроме того, в зависимости от основного режима, в буфере могут быть определены
другие структурные единицы, например, выражения и функции в языках
программирования.

Интересным следствием правил расширения региона также является то, что если
поставить курсор перед открывающейся скобкой или после закрывающейся
(соответствующая пара скобок при этом подсветится) - при нажатии =C-==, скобки
будут выделены вместе со всем содержимым.

** Базовые операции

Итак, допустим регион выделен - но что же с ним делать? Список основных действий
с регионами таков:

1) При нажатии печатных символов на клавиатуре регион
   будет удалён и набранные символы появятся на его месте.
2) При нажатии клавиш =C-d= или =C-h= и регион будет просто
   удален.
3) При нажатии на символы открывающихся скобок - "(", "{", "[", а
   также символ кавычки, регион будет /обернут/ (wrapped) - набранный символ
   вставится в начало региона, а соответствующий закрывающий символ - в конец.
4) При нажатии =M-w= регион будет скопирован.
5) При нажатии =C-w= регион будет вырезан.

Список можно было бы назвать самым обычным, если бы не особенности копирования и
вставки в Emacs. В англоязычной документации для этих действий даже специально
употребляются слова kill/yank, вместо традиционных cut/paste. Я не придумывал
специальные русские термины для того, чтобы подчеркнуть эту разницу, поэтому
употребляю общеизвестные вырезать/вставить, хотя, наверное, это и не совсем
корректно.

Главное отличие рассматриваемых команд в Emacs от традиционных редакторов в том,
что вырезаемые данные записываются в последовательность, называемую /кольцо
вставки/ (kill ring). Т.е. в каждый момент времени у пользователя есть
возможность вставить не только самый последний вырезанный регион, а также и
любой другой, находящийся в кольце.

Как говорилось ранее, вставка последнего вырезанного региона осуществляется с
помощью =C-y=. Если следующей после нажатия =C-y= выполнить команду =M-y=, то
только что вставленный регион будет заменен своим предшественником из кольца
вставки.

Я нахожу такой подход крайне полезным и удобным - можно не переживать, что
вырезанные данные потеряются после следующего копирования.

В некоторых ситуациях (в основном, когда нужно найти что-то вырезанное давно),
удобно просмотреть содержимое кольца вставки. Для этого используется команда
=C-x C-y=. После того, как требуемые регион найден, его можно вставить нажатием
=C-m= (=Enter=).

Поскольку хранить абсолютно все вырезанные регионы нецелесообразно (они могут
занимать слишком много места), то выбранная структура хранения этих регионов -
именно кольцо. По умолчанию, его размер - 60 регионов. Т.е. 60 первых вырезанных
регионов будут записаны в кольцо друг за другом, а при вырезании следующего
(61-го) региона, из кольца будет удален самый старый (1-ый) регион, а 61-ый
будет записан вместо него и т.д.

** Дополнительные операции вырезания
*** Вырезание строк

В Emacs некоторые структурные единицы можно вырезать, предварительно не выделяя
их в регион. Одной из главных таких единиц является строка.

Вырезать текст от курсора до конца строки можно с помощью команды =C-k=. Обращаю
внимание, что при этом символ переноса строки не удаляется. Для того, чтобы его
удалить требуется повторно нажать =C-k=. Однако зачастую это не совсем приводит
к желаемому результату.

Допустим, мы редактируем следующий отрывок:

#+BEGIN_SRC d
  if (supported)
  {
      performOperation(first_argument,
                       second_argument);
  }
#+END_SRC

Мы хотим, чтобы круглые скобки находились на одной строке. Для этого, можно
поставить курсор после запятой и нажать =C-k=. Поскольку мы уже находимся в
конце строки, то будет удален (условно невидимый) символ перевода строки и
отрывок примет новый вид:

#+BEGIN_SRC d
  if (supported)
  {
      performOperation(first_argument,                     second_argument);
  }
#+END_SRC

Следующая строка (с текстом =second_argument);=) попала на текущую, но поскольку
перед началом буквенных символов в этой строке присутствовал также отступ из
пробельных символов, то и он благополучно попал на текущую строку.

Для того, чтобы с ним расправиться можно нажать =M-\= (fixup whitespace) - эта
команда превратит любое количество пробелов вокруг курсора в один.

Но есть и другой способ - вместо нажатия =C-k=, можно нажать =M-j= (join
following line). Эта команда как бы "подтягивает" текст следующей строчки на
текущую, после чего отрывок выглядит так:

#+BEGIN_SRC d
  if (supported)
  {
      performOperation(first_argument, second_argument);
  }
#+END_SRC

=M-j= - очень удобная команда - использовать её, кстати, можно не только когда
курсор находится в конце строки (с тем же результатом), но я отвлекся от главной
темы этого раздела - вырезания.

Итак, команда =C-k= удаляет строку от курсора и до её конца, а если курсор уже
находится в конце, то удаляется символ перевода строки. Поговорим ещё об
интересных особенностях этой команды.

Если её выполнить несколько раз подряд и потом осуществить вставку, то можно
заметить, что вставлены будут все вырезанные строки, а не только самая
последняя. Это обусловлено тем, что в Emacs действует следующее правило: если
вырезающей команде предшествовала другая вырезающая команда, то вместо создания
новой записи в кольце вставки, вырезанный регион приписывается к последней
записи.

Т.е. если 6 раз подряд нажать =C-k=, то будет вырезано три полных строки с
символами перевода строк и при следующем нажатии =C-y=, будут вставлены все 3
строки.

*** Вырезание слов

Внимательный читатель мог обратить внимание, что операции =M-d= и =M-h= не
удаляют, а вырезают соответствующие слова. Впрочем, в Emacs вообще практически
все операции, удаляющие текст длиннее одного символа, являются операциями
вырезания, что позволяет "не терять" содержательные куски. Значит, после
использования указанных команд слова можно вставить при помощи =C-y=. Кроме
того, на них также распространяется описанное только что правило -
последовательные исполнения этих команд складируют вырезанные слова в первом
элементе кольца вставки.

Пытливый читатель может заметить, что эта функциональность перекрывается с
выделением регионов, и резонно задать вопрос - а что лучше/эффективнее
использовать - =C-SPC=, =M-f=, =M-f=, =M-f=, =C-w= или =M-d=, =M-d=, =M-d= и
почему вообще существует 2 способа сделать одно и то же?

Причина здесь, как часто бывает, историческая. Мы все давно привыкли к
использованию регионов, но было время, когда их использование не было так
распространено. На старых терминалах у символов нельзя было изменять фон, а
значит - нельзя было "подсветить" выделенный регион. Т.е. использовать регионы в
Emacs можно было точно так же, как и сейчас, но увидеть выделенный регион было
нельзя, что было несколько неудобно. Я предполагаю, что именно этот факт и
явился главной причиной того, почему вырезание и вставка в Emacs работают так,
как работают. Такой подход позволяет альтернативным способом визуализировать то,
что происходит - вместо выделения региона, куски текста вырезались. Сегодня,
когда вопрос о цвете фона символов стоит не так остро, наверное, проще всегда
использовать регионы, если нужно вырезать больше одного слова (во всяком случае
я делаю так в 95% случаев).

Казалось бы, выделять регион можно и когда требуется вырезать всего одно слово,
воспользовавшись комбинациями =C-==, =C-w=. Но, во-первых, всё-таки в голове это
проходит по двум пунктам - "выделить слово и вырезать", вместо - "вырезать
слово", во-вторых, это и две комбинации вместо одной, ну и, в-третьих, есть одно
отличие в работе этих команд от =M-d= и =M-h=, которое позволяет им очень удачно
дополнять друг друга.

В программировании часто используется т.н. "верблюжий" стиль (camel case)
именования функций, переменных и т.п. - разные слова в имени начинаются с
заглавных букв, например - LongFunctionName или longFunctionName.

Так вот, комбинация =C-==, =C-w= вырезает всё имя функции целиком, а команды
=M-d= и =M-h= вырезают "подслова" в имени.

*** Вырезание до символа

Как уже было сказано, чаще всего для вырезания лично я использую выделение
региона и в сегодняшних реалиях наличие большого количества специальных команд в
Emacs на этот счет, наверное, несколько утратило актуальность.

Но тем не менее, я всё-таки хочу рассказать о последней специальной команде,
которая довольно часто пригождается - =M-z= (zap to char).

Допустим, курсор находится в середине предложения и мы хотим вырезать все
символы до его конца, начиная с позиции курсора. Для этого нужно нажать =M-z=,
после чего будет предложено ввести символ, до которого нужно осуществлять
вырезание. В нашем случае это точка. После её нажатия, будут вырезаны все
символы между текущим положением курсора и ближайшей точкой, включая её.

Для того, чтобы оставить точку, можно воспользоваться командой =M-Z= (zap up to
char), которая во всём эквивалента =M-z=, кроме того, что не вырезает указанный
символ.

* Префиксный аргумент

Сейчас я хочу коротко рассмотреть, наверное, не самый жизненно важный вопрос, но
вряд ли для него найдется лучшее место.

** Численный аргумент

Начну с того, на чем закончился предыдущий раздел - команды =M-z=, которая
вырезает все символы, начиная с текущей позиции курсора до первого появления
укзанного символа (включая сам символ).

Допустим, мы с её помощью хотим удалить деепричастный оборот в предложении
"Убедившись, что понять этого он не может, ему стало скучно (Л. Толстой)".
Деепричастный оборот расположен в самом начале предложения и заканичается
запятой после слова "может". Соответственно, для того, чтобы его удалить, можно
расположить курсор в начале предложения, нажать =M-z=, запятую - таким образом
вырежется текст до первой запятой ("Убедившись,") - а потом опять =M-z= и
запятую - чтобы вырезать весь необходимый текст. Т.е. для достижения цели нам
пришлось 2 раза подряд выполнить одну и ту же команду.

В таких ситуациях удобно передать исполняемой команде /префиксный аргумент/. В
рассмотреном примере вместо того, чтобы два раза выполнить одну и ту же команду,
можно выполнить =C-2 M-z= и нажать запятую, для достижения того же результата.

Т.е. любой команде в Emacs можно передать префиксный аргумент нажатием =C-<NUM>=
перед самой командой. В подавляющем большинстве случаев это будет сигналом к
тому, что указанную команду нужно выполнить =<NUM>= раз.

Один пример использования префиксного аргумента (вкупе с командой =M-z=) уже был
рассмотрен. Вот другие примеры:

- =C-3 M-Z= - вырезать текст до третьего появления указанного символа (исключая
  сам символ)
- =С-8 0 /= или =С-8 С-0 /= - вставить 80 символов '/'
- =C-5 C-n= - спустить курсор на 5 строчек вниз
- =C-6 C-k= - вырезать 6 строк

Последний пример требует определенного пояснения. Если 6 раз подряд выполнить
команду =C-k=, то вырезаны будут всего 3 строчки, потому что первое нажатие
вырежет текст до конца строки; второе - символ конца строки; третье, по аналогии
с первым - текст до конца строки и т.д. Однако, если нажать =C-6 C-k=, то
вырезаны будут именно 6 строк.

Связано это с тем, что, вообще говоря, правило о том, что префиксный аргумент
означает количество раз, которое нужно повторить следующую команду не является
строгим. Т.е. этот функционал реализован не на уровне Emacs, а на уровне самих
функций. И описанное правило является всего лишь соглашением, которому должны
следовать "правильные" функции.

В случае с функцией вырезания строки, она позволяет себе некоторую вольность -
вырезать именно столько строк, сколько указано префиксным аргументом, а не
делить его пополам. И в данном случае эта вольность является вполне уместной,
потому что функция ведет себя вполне ожидаемо и адекватно.

Для некоторых команд предписание "выполнись N раз подряд" не имеет особого
смысла. Например, функция =C-l= располагает содержимое буфера так, чтобы курсор
оказался в центре окна, последовательное нажатие располагает содержимое, чтобы
курсор оказался вверху, потом - внизу, а потом опять в центре - и так по кругу.
Особого смысла предоставлять возможность выполнить эту команду произвольное
число раз подряд нету, поскольку, фактически, у неё всего 3 возможных исхода.

В таких случаях авторы функций, как правило, стараются подобрать для префиксного
аргумента какое-нибудь более или менее осмысленное значение. Функция =C-l=,
например, если ей передать N в качестве аргумента, расположит содержимое буфера
так, чтобы курсор находился на (N+1)-ой строчке окна.

** Отрицательный аргумент

Будучи математиком по образованию и профессии, могу предположить, что
разработчиками Emacs двигала та же мотивация, что и Диофантом, когда они стали
использовать отрицательные префиксные аргументы. Объяснить с бытовой точки
зрения, что значит выполнить команду минус 3 раза не очень просто, но слишком уж
гармонично всё выстраивается, если наплевать на эту бытовую точку зрения!

К примеру, если выполнить =C-- 3 C-n=, то курсор переместится на три строки
вверх, несмотря на то, что мы выполнили команду перевода курсора вниз. В погоне
за красивыми математическими параллелями можно даже отметить, что после
выполнения команды курсор попадает в такую точку, что если в ней выполнить =C-3
C-n=, то он окажется в исходном положении!

Аналогично, если выполнить =C-- M-z= (минус в качестве префиксного аргумента
эквивалентен минус единице), то будет вырезан кусок текста с текущего положения
до ближайшего появления указанного символа *перед* курсором.

Как и в случае с положительными префиксными аргументами, какого-то строгого
правила, что делать с отрицательными аргументами нет. Но негласная
договорённость состоит в том, что они должны модифицировать выполнение команды
точно так же, как и положительные, только наоборот.

** Универсальный аргумент

Помимо численных префиксных аргументов, функциям можно передать т.н.
/универсальный аргумент/ при помощи префикса =C-u=.

Если численный аргумент чаще всего означает "выполнить следующую команду N раз",
то универсальный аргумент имеет несколько значений.

Во-первых, если команда не обрабатывает его особенно, то он соответствует
численному аргументу, равному 4. Почему именно четырем сказать трудно, но с
другой стороны, а почему бы и нет?! Например, =C-u C-m= - вставить 4 пустых
строки, =C-u C-u C-m= - вставить 16 пустых строк, =C-u C-u C-u C-m= - вставить
64 пустых строки и т.д. Естественно, точные значения, получаемые при помощи
универсального аргумента (степени четверки) не очень полезны, но можно
относиться к этим величинам, как к качественным:

- один аргумент - "повтори несколько раз",
- два аргумента - "повтори с дюжину раз",
- три аргумента - "повтори с полсотни раз",
- четыре аргумента - "повтори с сотню раз" и т.д.

Во-вторых, универсальный аргумент может сигнализировать команде "выполнись, но
не как обычно". Что именно значит "не как обычно" каждая команда решает
по-своему. В качестве примера, рассмотрим команду =C-y=, ради чего я и завел
разговор о префиксных аргументах именно сейчас.

Допустим, у нас есть следующий кусок кода:

#+BEGIN_SRC d
  int fun()
  {
      if (supported)
      {
          performFirstOperation(first_argument, second_argument);
      }

      performSecondOperation();
      performThirdOperation();
  }
#+END_SRC

И мы решили, что и вторую и третью операцию нужно выполнять, только при условии
=supported=. Т.е. мы хотим преобразовать этот код в следующий:

#+BEGIN_SRC d
  int fun()
  {
      if (supported)
      {
          performFirstOperation(first_argument, second_argument);
          performSecondOperation();
          performThirdOperation();
      }
  }
#+END_SRC

Очевидное решение было бы следующим - вырезать строчки

#+BEGIN_SRC d
  performSecondOperation();
  performThirdOperation();
#+END_SRC

и вставить их куда надо - что может быть проще?! Однако, тут имеется тонкий
момент. В какое положение нужно поставить курсор для выделения региона и в какое
положение его нужно поставить для вставки?

Допустим, мы поставим курсор перед первой буквой "p" и вставим ровно в том
положении, где она должна оказаться. Тогда (в "обычном" редакторе) мы получим
следующую картину:

#+BEGIN_SRC d
  int fun()
  {
      if (supported)
      {
          performFirstOperation(first_argument, second_argument);
          performSecondOperation();
      performThirdOperation();
      }
  }
#+END_SRC

Другой вариант - поставим курсор в начале строки с вызовом функции
=performFirstOperation()=, а при вставке - в начало строки, где мы хотим
расположить вырезанный кусок, тогда получим:

#+BEGIN_SRC d
  int fun()
  {
      if (supported)
      {
          performFirstOperation(first_argument, second_argument);
      performSecondOperation();
      performThirdOperation();
      }
  }
#+END_SRC

И, вообще говоря, как бы мы ни старались - в "обычном" редакторе вставленный
текст всегда будет выровнен неправильно. А значит, после вставки его придется
ещё и форматировать.

В Emacs же эта проблема не стоит. Вставленный текст будет выровнен
автоматически. Т.е. где бы ты ни расположил курсор для вырезания (в начале
строки или начале текста) и где бы ты ни расположил курсор для вставки -
результат будет выглядеть "как надо".

Это настолько удобная и сама собой разумеющаяся функция, что я привык к ней ещё
до того, как начал пользоваться, и постоянно ругался вслух, когда приходилось
выравнивать только что вставленный текст.

Но в редких случаях, такое выравнивание будет играть не на руку - регион нужно
просто вставить "как есть". Тогда можно передать команде вставки универсальный
аргумент - =C-u C-y= - и текст будет вставлен без автоматического выравнивания.

* Undo/Redo

Как известно, не ошибается тот, кто ничего не делает, поэтому Emacs
предоставляет возможность откатить последние действия. Для этого можно
использовать сочетание =C-z= (как и в других редакторах), либо =С-/=. Лично я
использую =C-/=, потому что его удобнее нажимать.

В целом, эта тема не стоила бы отдельного раздела, если бы мы не ошибались во
время исправления наших ошибок - жмешь =C-/= столько раз, сколько нужно, пока
все ошибки не исчезнут.

Но что делать, если ты нажал =C-/= лишнего и теперь тебе нужно вернуть всё, как
было перед последним нажатием? Рассмотрим такой пример: первой командой мы ввели
слово "Береги ", второй - "деньги ", третьей - "смолоду". Как мы это делали -
не очень важно - мы могли как набирать слова по отдельным символам, так и
вставлять их различными способами (не обо всех из которых я успел сказать) -
главное, что мы выполнили три команды вставки.

Проиллюстрируем это следующей диаграммой:

#+BEGIN_EXAMPLE
                               o  (пустой буфер)
                               |
                               |
                               o  Береги (ввод)
                               |
                               |
                               o  Береги деньги (ввод)
                               |
                               |
                               x  Береги деньги смолоду (ввод)
#+END_EXAMPLE

Теперь, допустим, мы пересмотрели свои ценности и захотели исправить ошибку во
втором слове.

* Поиск
- C-s, C-r (не забыть, что можно выделить и нажать и оно его будет искать), M-s
  o, M-% (C-q C-j)
* Как поставить dmd
- dired (открыть директорию в ido) - должен быть в самом начале!
- M-&
- пишем программу - комментарии, M-q
- компилируем
- создаем репозиторий, смотрим в магит
- выкладываем на гитхаб
- Таги

* Пишем презентацию в орг-моде, в маркдауне (починить нумерованый список)
* Разное
- backward-paragraph-scroll ????
- продвинутые команды редактирования ???
- M-g g
- C-x C-q
- C-o, M-j
- Парные скобочки, удаление
- Контекстное авто-дополнение
- M-p, M-n
- M-c, M-u, M-l
- C-x C-o, M-\
- M-z

- Редактирование под рутом
- hexl-mode
- grep, wgrep
- M-|
- registers
- редактирование в диред
- клавиатурные макросы
- несколько курсоров (rectangular regions)
- remote-term
- проверка правописания
- Выполнение лиспа
- Google, Lingvo, C-c C-o

* Заключение
- Научись делать, как товарищ сержант
- Пользование документацией
